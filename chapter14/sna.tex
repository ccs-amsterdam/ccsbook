\section{Social network analysis}
\label{sec:sna}

This section gives an overview of the existing measures to conduct Social Network Analysis (SNA). Among other functions, we explain how to examine paths and reachability, how to calculate centrality measures (degree, closeness, betweenness, eigenvector) to quantify the importance of a node in a graph, and how to detect communities in the graph using clustering.

\subsection{Paths and reachability}

The first idea that comes into our minds when analysing a graph is to understand how their nodes are connected. When multiple edges create a network we can observe how the vertices constitute one or many paths that can be described. In this sense, a \texttt{sequence} between node \textit{x} and node \textit{y} is a path where each node is \texttt{adjacent} to the previous. In the imaginary social network of friendship of American politicians contained in the undirected graph \texttt{g1}, we can determine the sequences or simple paths between any pair of politicians. As shown in \refex{path} we can use the function \fn{all\_simple\_paths} contained in both \pkg{igraph} (R) and \pkg{networkx} (Python), to obtain the two possible routes between Barack Obama and John McCain. The shortest path includes the nodes Hillary Clinton and Donald Trump; and the longer includes Bernie Sanders, Clinton and Trump.

\pyrex[output=both,caption=Possible paths between two nodes in the imaginary Facebook network of American politicians]{chapter14/path}

One specific type of path is the one in which the initial node is the same than the final node. This closed path is called a \texttt{circuit}. To understand this concept let us recover the inducted subgraph of Democrat politicians (\texttt{g3}) in which we only have three nodes. If you plot this graph, as we do in \refex{circuit}, you can clearly visualize how a circuit works. 

\pyrex[output=both,format=png,caption=Visualization of a circuit]{chapter14/circuit}

In SNA it is extremely important to be able to describe the possible paths since they help us to estimate the reachability of the vertices. For instance, if we go back to our original graph of American politicians in Facebook (\texttt{g1}) visualized in \refex{visgraph} we can see that Sanders is reachable from McCain because there is a path between the (McCain - Trump - Clinton - Sanders).  Moreover, we observe that this social network is fully \texttt{connected} because you can reach a given node from any other node in the graph. But it might not always be that way. Imagine that we remove the friendship of Clinton and Trump by deleting that specific edge that joins Republicans and Democrats. As you can observe in \refex{component}, when we create and visualize the graph \texttt{g6} without this edge we can see that the network is not longer fully connected and it has two \texttt{components}. Technically speaking, we would say for example that the subgraph of Republicans is a connected component of the network of American politicians, given that this connected subgraph is part of the bigger graph while not connected to it.

\pyrex[output=both,format=png,caption=Visualization of a connected component]{chapter14/component}

When analysing paths and reachability you may be interested in knowing the distances in your graph. One common question is what is the average path length of a social network, or in other words, what is the average of the shortest distance between each pair of vertices in the graph. This \texttt{mean distance} can tell you a lot about how close are the nodes in the network: the shorter the distance the closer the nodes are. Moreover, you can estimate the specific distance (shortest path) between two specific nodes.  As shown in \refex{distance} we can estimate the average path length (1.7) in our imaginary Facebook network of American politicians using the functions \fn{mean\_distance} in \pkg{igraph} and \fn{average\_shortest\_path\_length} in \pkg{networkx}. In this example we also estimate the specific distance in the network between Obama and McCain (3) using the function \fn{distances} in \pkg{igraph} and estimating the length (\fn{len}) of the shortest path (first result of \fn{shortest\_simple\_paths} minus 1) in \pkg{networkx}.

\pyrex[output=both,caption=Estimating distances in the network]{chapter14/distance}

In terms of distance, we can also wonder what are the edges or nodes that share a border with any given vertex. In the first case, we can identify the \texttt{incident edges} that go out or into one vertex. As shown in \refex{incident}, by using the the functions \fn{incident} in \pkg{igraph} and \fn{edges} in \pkg{networkx} we can easily get incident edges of John McCain in Facebook Network (\texttt{g1}), which is just one single edge that joins Trump with McCain. In the second case, we can also identify its adjacent nodes, or in other words its \texttt{neighbours}. In the very same example, we use \fn{neighbors} (same function in \pkg{igraph} and \pkg{networkx}) to obtain all the nodes one step away from McCain (in this case only Trump).

\pyrex[output=both,caption=Incident edges and neighbours of J. McCain the imaginary Facebook Network]{chapter14/incident}

There are some other interesting descriptors of social networks. One of the most common measures is the \texttt{density} of the graph, which accounts for the proportion of edges relative to all possible ties in the network. In simpler words, the density tells us from 0 to 1 how much connected are the nodes of a graph and it can be estimated for both, undirected and directed graphs. Using the functions \fn{edge\_density} in \pkg{igraph} and \fn{density} in \pkg{networkx} we obtain a density of 0.5 (middle level) in the imaginary Facebook network of American politicians (undirected graph) and 0.35 in the Twitter network (directed graph). 

In undirected graphs we can also measure \texttt{transitivity} (also known as \texttt{clustering coefficient} and \texttt{diameter}. The first is a key property of social networks that refers to the ratio of triangles over the total amount of connected triples. It is to say that we wonder how likely is that two nodes are connected if they share a mutual neighbour. Applying the function \fn{transitivity} (included in \pkg{igraph} and \pkg{networkx}) to \texttt{g1} we can see that this tendency is of 0.5 in the Facebook network. The second descriptor, the diameter, depicts the length of the network in terms of the longest geodesic distance\footnote{The \textit{geodesic distance} is the shortest number of edges between two vertices} . We use the function \fn{diameter} (included in \pkg{igraph} and \pkg{networkx}) in the Facebook network and get a diameter of 3, which you can also check if you go back to the visualization of \texttt{g1} in \refex{visgraph}. 

Additionally, in directed graphs we can calculate the \texttt{reciprocity}, which is just the proportion of reciprocal ties in a social network and can be computed with the function \fn{diameter} (included in \pkg{igraph} and \pkg{networkx}). For the imaginary Twitter network (directed graph) we get a reciprocity of 0.57 (which is not bad for a Twitter graph where important people usually have much more followers than follows!).

In \refex{density} we show how to estimate these four measures in R and Python. Notice that in some of the network descriptors you have to decide whether to include or not the edges weights for computation (in the provided examples we did not take these weights into account).

\pyrex[output=both,caption={Estimations of density, transitivity, diameter and reciprocity}]{chapter14/density}

\subsection{Centrality measures}

Now let us move to \texttt{centrality measures}. Centrality is probably the most common popular or known measure in the analysis of social networks because it gives you a clear idea of the importance of any of the nodes within a graph. Using its measures you can pose many questions such as which is the most central person in a network of friends in Facebook, who can be considerer an opinion leader in Twitter or who is an influencer in Instagram. Moreover, knowing the specific importance of every node of the network can help us to visualize or label only certain vertices that overpass a determine threshold, or to use the color or size to distinguish the most central nodes from the others. There are four typical centrality measures: \texttt{degree}, \texttt{closeness}, \texttt{eigenvector} and \texttt{betweenness}.

The \texttt{degree} of a node refers to the number of ties of that vertex, or in other words, to the number of edges that are incident to that node. This definition is constant for undirected graphs in which the directions of the links are not declared. In the case of directed graphs, you will have three options to measure the degree. First, you can think of the amount of edges pointing \texttt{in} any node, which we call \texttt{in degree}; second, we have the number of edges pointing \texttt{out} any node, or \texttt{out degree}. In addition, we could also have the total number of edges pointing (in and out) any node. \texttt{Degree}, as well of other measures of centrality mentioned below, can be expressed in absolute numbers, but also we can \texttt{normalize}\footnote{The approach is to divide by the maximum possible number of vertices (N) minus 1, or by N-1. We may also estimate the \texttt{weighted degree} of a node, which is the same degree but ponderated by the weight of the edges.}  this measure for better interpretation and and comparison. We will prefer this last approach in our examples, which is also the default option in many SNA packages.

We can then estimate the degree of two of our example networks. In \refex{centrality1} we first estimated the degree of each of the five American politicians in the imaginary Facebook network, which is a undirected graph; and then the total degree in the Twitter network, which is a directed graph. For both cases, we use the functions \fn{degree} in \pkg{igraph} (R) and \fn{degree\_centrality} in \pkg{networkx} (Python). We later computed the \texttt{in} and \texttt{out} degree for the Twitter network. In \pkg{igraph} we used again the function \fn{degree} but adjusting the parameter \texttt{mode} to "in" or "our", respectively; and in \pkg{networkx} we employed the functions \fn{in\_degree\_centrality} and \fn{out\_degree\_centrality}.

\pyrex[output=both,caption={Computing degree centralities in undirected and directed graphs}]{chapter14/centrality1}

There are three other types of centrality measures. \texttt{Closeness} centrality refers to the geodesic distance of a node to the rest of nodes in the graph. Specifically, it indicates how close a node is from the others by taking the length of the shortest paths between the vertices. \texttt{Eigenvector} centrality takes into account the importance of the surrounding nodes and computes the centrality of a vertex based on the centrality of its neighbours. In technical words, the measure is proportional to the sum of connection centralities. Finally, \texttt{betweenness} centrality indicates to which extent the node is in the paths that connect many other nodes. Mathematically it is computed as the sum of the fraction of every pair of (shortest) paths that go through the analysed node. 

As shown in \refex{centrality2}, we can obtain these three measures from undirected graphs using the functions \fn{closeness}, \fn{eigen\_centrality} and \fn{betweenness} in \pkg{igraph}, and \fn{closeness\_centrality}, \fn{eigenvector\_centrality} and \fn{betweenness\_centrality} in \pkg{networkx}. If we take a look to the centrality measures for every politician of the imaginary Facebook network we see that Clinton seems to be a very important and central node of the graph, just coinciding with the above-mentioned findings based on the degree. It is not a rule that we obtain the very same trend in each of the centrality measures but it is likely that they have similar results although they are looking for different dimensions of the same construct.

\pyrex[output=both,caption={Estimations of density, transitivity, diameter and reciprocity}]{chapter14/centrality2}

We can use these centrality measures in many ways. For example, you can take the degree centrality as a parameter of the node size and labelling when plotting the network. This may be of great utility since the reader can visually identify the most important nodes of the network while minimizing the visual impact of those that are less central. In \refex{plotsize} we decided to specify the size of the nodes (parameters \verb|vertex.size| in \pkg{igraph} and \verb|node_size| in \pkg{networkx}) with the degree centrality of each of the American politicians in the Twitter network (directed graph) contained in \texttt{g2}. We also used the degree centrality to filter the labels in the graph, and then included only those that overpassed a threshold of 0.5 (parameters \verb|vertex.label| in \pkg{igraph} and \verb|labels| in \pkg{networkx}). These two simple parameters of the plot gives you a fair image of the potentiality of the centrality measures to describe and understand your social network.

\pyrex[output=both,format=png,caption=Using the degree centrality to change the size and labels of the nodes]{chapter14/plotsize}

\subsection{Clustering and community detection}

One of the greatest potentialities of SNA is the ability to identify how nodes are interconnected and thus define \texttt{communities} within a graph. This is to say that most of the times the nodes and edges in our network are no distributed homogeneously, but they tend to form clusters that can be later interpreted. In a social network you can think for example in the principle of \texttt{homophily}, which is the tendency of human beings to associate and interact with similar individuals; or you can think of extrinsic factors (i.e. economical or legal) that may generate the cohesion of small groups of citizens that belong to a wider social structure. With independence to the original cause, we use different computational approaches to model and detect possible communities that emerge from social networks and even to interpret and label those groups. The creation of clusters as an unsupervised machine learning technique was introduced in Section~\ref{sec:clustering} for structured data and in Section~\ref{sec:unsupervised} for text analysis (topic modeling). We will use some similar unsupervised approaches for community detection in social networks.

Many social and communication questions may arise when clustering a network. The identification of subgroups can tell us how diverse and fragmented a network is, or  what is the behaviour of a specific community in relation to other groups and to the entire graph. Moreover, the concentration of edges in some nodes of the graph would let us know about the social structure of the networks which in turn would mean a better understanding of its inner dynamic.  It is true that the computational analyst will need more than the provided algorithms when labelling the groups to understand the communities, which means that you must get familiar with the way graph has been built and what their nodes, edges or weights represent.

A first step to get involved with subgroups within a network is to find the available complete subgraphs in an undirected graph. As we briefly explained at the end of Section~\ref{sec:graph}, these independent subgraphs are called \texttt{cliques} and refer to subgroups where every vertex is connected to every other vertex. We can find the \texttt{maximal cliques} (a clique is maximal when it cannot be extended to a  bigger clique) in the imaginary undirected graph of American politicians in Facebook (\texttt{g1}) by using the functions \fn{max\_cliques} in \pkg{igraph} \citep{eppstein2010listing} and \fn{max\_cliques} in \pkg{networkx} \citep{cazals2008note}. As you can see in \refex{cliques}, we obtain a total of 3 subgraphs, one representing the Democrats, another the Republicans, and one more the connector of the two parties (Clinton-Trump).

\pyrex[output=both,caption={Finding all the maximal cliques in an undirected graph}]{chapter14/cliques}

Now, in order to properly detect communities we will apply some common algorithms to obtain the most likely subgroups in a social network. The first of these models is the so called \texttt{edge-between} or Girvan-Newman algorithm \citep{newman2004finding}. This algorithm is based on divisive hierarchical clustering (explained in Section~\ref{sec:unsupervised}) by breaking down the graph into pieces and iteratively removing edges from the original one. Specifically,  Girvan-Newman approach uses betweenness centrality measure to remove the most central edge at each iteration. You can easily visualize this splitting process in a dendrogram, as we do in \refex{girvan}, where we estimated \texttt{cluster1} to detect possible communities in the Facebook network. We used the functions \fn{cluster\_edge\_betweenness} in \pkg{igraph} and \fn{girvan\_newman} in \pkg{networkx}.

\pyrex[output=r,format=png,caption=Dendrogram to visualize clustering with Girvan-Newman]{chapter14/girvan}

When you look at the figure you will notice that the final leaves correspond to the nodes (the politicians) and then you have different partition levels (1 to 4), which in fact are different cluster possibilities. In edge-betweenness clustering the big question is which partition level to choose, or in other words, which of the community division is better. The concept of \texttt{modularity} arises as a good measure (-1 to 1) to evaluate how good the division is. Thus, we can choose which of the four proposed division is the best based on the highest value of their modularities: The higher the modularity the more dense the connections \textit{within} the community and the more sparse the connections \textit{across} communities. In the case of \fn{cluster\_edge\_betweenness} in \pkg{igraph} it automatically estimates that the best division (on modularity) is the first one with two communities.

\pyrex[output=both,caption={Community detection with Girvan-Newman}]{chapter14/girvan2}

For most community detection algorithms we can estimate its length (number of suggested clusters), membership (to which cluster belongs each node) and modularity (how good is the clustering). For the case of \pkg{igraph} in R we apply the functions \fn{length} (base), \fn{membership} and \fn{modularity} over the produced clustering object (i.e. \texttt{cluster1}). In the case of \pkg{networkx} in Python we first have to specify that we want to use the first component of the divisions (out of 4) using the function \fn{next}. Then, we can apply the functions \fn{len} (base) and \fn{modularity} to get the descriptors, and print the fist division (stored as \texttt{communities1}) to obtain the membership.

We can estimate the communities for our network using many other more clustering algorithms, such as \texttt{Louvain}, \texttt{Propagating Label} and \texttt{Greedy Optimization}, among others. Similar to Girvan-Newman, Louvain algorithm uses the measure of modularity to obtain a multi-level optimization \citep{blondel2008fast} and its goal is to obtain optimized clusters where the less number of edges between the communities and a higher number edges within the same community. For its part, the Greedy Optimization algorithm is also based on the modularity indicator \citep{clauset2004finding}. It does not consider the edges weights and works by initially setting each vertex in its own community and then joining two communities to increase modularity until obtaining the maximum modularity. Finally, the Propagating Label algorithm -which takes into account edges weights- initializes each node with a unique label and then iteratively each vertex adopts the label of its neighbours until all nodes have the most common label of their neighbours \citep{raghavan2007near}. The process can be conducted asynchronous (the one we choose in our example), synchronous or semi-synchronously; and it might produce different results at each execution.

In \refex{clustalgo} we use \fn{cluster\_louvain}, \fn{cluster\_fast\_greedy} and \fn{cluster\_label\_prop} in \pkg{igrapgh} (R) and \fn{best\_partition}, \fn{greedy\_modularity\_communities} and \fn{asyn\_lpa\_communities} in \pkg{networkx} (Python). You can notice  that the results are quite similar\footnote{This similarity is because our example network is extremely small. In larger networks, the results might not be that similar.}  and it is pretty clear that there are two communities in the Facebook network: Democrats and Republicans!

\pyrex[output=both,caption={Community detection with Louvain\, Propagating Label and Greedy Optimization}]{chapter14/clustalgo}

We can plot each of those clusters for better visualization of the communities. In \refex{plotcluster} we generate the plots with the Greedy Optimization algorithm in R and the Louvain algorithm in Python, and we get two identical results.

\pyrex[output=both,format=png,caption=Plotting clusters with Greedy optimization in R and Louvain in Python]{chapter14/plotcluster}

There are more ways to obtain subgraphs of your network (such as the \texttt{K-core decomposition}) or to evaluate the homophily of your graph (using the indicator of \texttt{assortativity} that measures the degree to which the nodes associate to similar vertices). In fact, the are many other measures and techniques to conduct SNA that we have deliberately omitted in this section for reasons of space, but we have covered the most important aspects and procedures you need to know to initiate yourself in the computational analysis of networks.
