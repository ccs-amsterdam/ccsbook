\section{Authentication, cookies, and sessions}
\label{sec:authentication}

\todo[inline]{We need to discuss what else needs to go in here. Originally, it said, for instance: OAuth. BUT: is there any situation in which someone will use OAuthlib directly? For virtually all APIs that use Oauth, there is some wrapper; and we decided not to discuss specific APIs (``the Twitter API'') because these things get outdated fast. Also, everything is so tailored to specific examples that it is hard to give general guidance. Ideas?}

In this chapter, we briefly discuss different approaches for dealing
with web services where you need to log on, accept something (e.g., a
so-called cookie wall), or have to otherwise authenticate yourself.
One approach can be the use of a web testing framework like Selenium
(see \refsec{selenium}): You let your script literally open a browser
and, for instance, fill in your login information.

However, the sometimes, that's not necessary and we can still use simpler
and more efficent webscraping without invoking a browser. As we have already
seen in \refsec{parsehtml}, when making an HTTP request, we can transmit
additional information, such as the so-called user-agent string. In a
similar way, we can pass other information, such as cookies.

In the developer tools of your browser (which we already used to determine
XPATHs and CSS selectors), you can look up which cookies a specific website
has placed. For instance, you could inspect all cookies \emph{before} you
logged on (or passed a cookie wall) and again inspect them afterwards to
determine what has changed. With this kind of reverse-engeneering, you
can find out what cookies you need to manually set.

In \refex{cookiewall}, we illustrate this for a specific page (at the
time of writing of our book). Here, by inspecting the cookies in Firefox,
we found out that clicking ``Accept'' on the cookie wall landing page
caused a cookie with the name |cpc| and the value |10| to be set. We
therefore then proceeded as followed. Also, during the first visit,
a couple of other cookies seemed to be set, the functionality of which
we did not care. In \refex{cookiewall}, we therefore start a \emph{session}
and try to download the page. We know that this will only show us the
cookie wall -- but it will also generate the necessary cookies. We then
store these cookies, and add the cookie that we want to be set (|cpc=10|)
to this cookie jar. Now, we have all cookies that we need for future
requests. They will stay there for the whole session.

If we only want to get a single page, we may not need to start a session
to remeber the cookies and all, and we can just directly pass the single
cookie we care about to a request instead (\refex{cookiewall2}).




\pyrex[output=py,input=py, caption={Explicitly setting a cookie to circumvent a cookie wall}]{chapter13/cookiewall}
\pyrex[output=none,input=py, caption={Shorter version of \refex{cookiewall} for single requests}]{chapter13/cookiewall2}





