\section{Simple control structures: loops and conditions}	
\label{sec:controlstructures}

\begin{feature}\textbf{Control structures in Python and R}
  This section and the next explains the working of control structures
  such as loops, conditions, and functions.
  These exist (and are very useful) in both Python and R.
  In R, however, you do not need them as much because most functions
  can work on whole columns in one go, while in Python you often run things
  on each row of a column.
  Thus, if you are primarily interested in using R you could consider skipping
  the remainder of this chapter for now and returning later when you are ready to learn more.
  If you are learning Python, we strongly recommend continuing this chapter as
  control structures are used in many of the examples in the book.
  \end{feature}
  


Having a clear understanding of objects and datatypes is a fist step
towards comprehending how object-orientated languages such as R and Python work,
but now we need to get some literacy of how to write code and \emph{interact}
with the computer and the objects we created. Learning a programming
language is just like learning any new language.  Imagine you want to
speak Italian or you want to learn how to play the piano. First thing
will be to learn some words or musical notes, and to get familiarized
with some examples or basic structures -- just as we did in \refchap{fundata}. In the
case of Italian or piano, you would then have to learn next some grammar:
How to form sentences, how play some chords; or, more generally,
how to reproduce patterns. And this is exactly how we 
now move on to acquiring computational literacy: by learning some
rules to make the computer do exactly what you want.

Remember that you can interact with R and Python directly on their
consoles just by typing any given command. However, when
you begin to use several of these commands and combine them
you will need to put all these instructions into a
script that you can then run partially or entirely. Recall \refchap{installing},
where we showed how IDEs such as RStudio or Spyder offer both a
console for directly typing single commands and a larger window
for writing longer scripts.

Both R and Python are \emph{interpreted} languages (as opposed to
\emph{compiled} languages), which means that interacting with
them is very straightforward: You provide your computer with some
\emph{statements} (directly or from a script), and your computer
reacts. We call a sequence of these statements a \emph{computer program}.
When we created objects by writing, for instance,
|a = 100|,  we already dealt with a very basic statement, the\emph{assignment statement}. But of course the statements can be more complex.

In particular, we may want to say more about how and when
statements needs to be executed. Maybe we want to repeat
the calculation of a value for each item on a list, or maybe
we want to do this only if some condition is fulfilled.

Both, R and Python have such \emph{loops} and \emph{conditional statements}, which will
make your coding journey much easier and with more sophisticated
results because you can control the way your statements are
executed. By controlling the flow of instructions you can deal with a
lot of challenges in computer programming such as iterating over
unlimited cases or executing part of your code as a function of new
inputs.

In your script, you usually indicate such loops and conditions
visually by using \emph{indentation}. Logical empty spaces -- two in R and four in
Pyhton -- depict blocks and sub-blocks on your code structure.
As you will see in the next section, in R, using indention
is optional, and curly brackets will indicate the beginning (|\{|)
and end )|\}| of a code block; whereas in Python, indention
is mandatory and tells your interpreter where the block
starts and ends.





\subsection{Loops}
\label{sec:loops}
Loops can be used to repeat a block of statements.
They are are executed once, indefinitely, or
until a certain condition is reached. This means that you can operate
over a set of objects as many times as you want just by giving one
instruction. The most common types of loops are \emph{for},
\emph{while} and \emph{repeat} (do-while), but we will be mostly
concerned with so-called for-loops. Imagine you have a list of
headlines as an object and you want a simple script
to print the length of each message. Of course you can go headline
by headline using the indexing, but you will get bored or will not
have time enough if you have thousands of cases. Thus, the idea is to
operate a loop in the list so you can get all the results, from the
first until the last element, with just one instruction.  The syntax
of the for-loop is:

\noindent\rule{\textwidth}{.5pt}\vspace{-1em}

\noindent\begin{minipage}[t]{.45\textwidth}
  For-loops in R:
\begin{verbatim}
for (val in sequence) {
    statement1
    statement2
    statement3
  }
\end{verbatim}
\end{minipage}
\begin{minipage}[t]{.45\textwidth}
  For-loops in Python:
\begin{verbatim}
for var in iterable:
    statement1
    statement2
    statement3
\end{verbatim}
\end{minipage}
\vspace{.5em}

\noindent\rule{\textwidth}{.5pt}

\pyrex[caption={For loops let you repeat operations.}]{chapter03/forloop}

As \refex{forloop} illustrates, every time you find yourself
\emph{repeating} something, for instance printing each element from a
list, you can get the same results easier by \emph{iterating} or
\emph{looping} over the elements of the list, in this case.  Notice
that you have same results, but with the loop you can automatize your
operation writing few lines of code. As we will stress along this
book, a good practice in coding is to be efficient and harmonious in
the amount of code we write, which is another justification for using
loops.

\note{\textbf{Don't repeat yourself!} You may be used to copy-pasting
  syntax and slightly changing it when working with some statistics
  program: you run an analysis and then you want to repeat the same
  analysis with different datasets or different specifications. But
  this is error-prone and hard to maintain, as it involves a lot of
  extra work if you want to change something. In many cases where you
  find yourself pasting multiple versions of the dataset, you can
  probably better use a for loop instead.}


Another way to iterate in Python is using list comprehensions  (not available natively in R), which are a stylish way to create list of elements automatically even with conditional clauses. This is the syntax:

\begin{verbatim}
newlist  = [expression for item in list if conditional]
\end{verbatim}

In \refex{listcomprehesions} we provide a simple example (without any
conditional clause) that creates a list with the number of characters
of each headline. As this example illustrates, list comprehensions
allow you to essentially write a whole for-loop in one
line. Therefore, list comprehensions are very popular in Python.

\pyrex[input=py,output=py,caption=List comprehensions are very popular in Python]{chapter03/listcomprehensions}



\subsection{Conditional statements}

Conditional statements will allow you to control the flow and order of
the statements written on your code. This means you can mandate the
machine to do this or that, depending on a given circumstance. These
statements use logic operators to test \emph{if} your condition is met
(True) or not (False) and execute an instruction accordingly. Both in
R and Python, we use the clauses \emph{if}, \emph{else if}
(\emph{elif} in Python) and \emph{else} to write the syntax of the
conditional statements. Let's begin showing you the basic structure of
the conditional statement:



\noindent\rule{\textwidth}{.5pt}\vspace{-1em}

\noindent\begin{minipage}[t]{.45\textwidth}
  If-statement in R:
\begin{verbatim}
if (condition) {
    Statement1
} else if{
    Statement2
}
else {
    Statement3
}
\end{verbatim}
\end{minipage}
\begin{minipage}[t]{.45\textwidth}
  If-statement in Python:
\begin{verbatim}
if condition_1:
    statement_1
elif condition_2:
    statement_2
else:
    statement_3
\end{verbatim}
\end{minipage}
\vspace{.5em}

\noindent\rule{\textwidth}{.5pt}


Imagine you want to print the headlines of \refex{forloop} only if the text is less than 40 characters long. We can include the conditional statement in the loop adding the next code to the script:

\pyrex[caption=A simple conditional control structure, output=py]{chapter03/if1}

We could also make it a bit more complicated: First check whether the length is smaller than 40, then check whether it is exactly 44 (|elif| / |else if|), and finally specify what to do if none of the conditions was met (|else|).

In \refex{if2}, we will print the headline if it is shorter than 40 characters, print the string ``What a surprise!'' if it is exactly 44 characers, and print ``NaN'' in all other cases. 

\pyrex[caption=A more complex conditional control structure, output=py]{chapter03/if2}

Notice that we have included the clause \emph{elif} in the structure (in R it is noted \emph{else if}). \emph{elif} is just another clause which statement must be executed only if an earlier condition was not satisfied. However, the reasoning behind the logic operators remains the same.
