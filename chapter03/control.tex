\section{Simple control structures: loops and conditions}	
\label{sec:controlstructures}

\subsection{Loops}
Having a clear understanding of what an object is allows us to
comprehend how object-orientated languages such as R and Python work,
but now we need to get some literacy of how to write code and interact
with the computer using these programs. Learning a programming
language is just like learning any new language.  Imagine you want to
speak Italian or you want to learn how to play the piano. First thing
will be to learn some words or musical notes, and to get familiarized
with some examples or basic structures. This is what we have done so
far in the last sections and chapters by providing real examples of
computational analysis of communication and explaining you the main
types of objects you will have to deal with in R and Python. In the
case of Italian or piano, you would have to learn next some grammar:
How to form sentences in different times or how play some accords and
reproduce patterns, respectively. And this is exactly how we should
now move on to acquiring computational literacy; by learning some
rules to make the computer do exactly what you want.

Remember that you can interact with R and Python directly on their
consoles just by typing any given command on the shell. However, when
you begin to use several of these commands and combine them with a
specific syntax you will need to put all these instructions into a
script that can run partially or entirely. Scripts are very useful as
the syntax of our code becomes more complex and you move to many
levels of \emph{indentation} (logical empty spaces -- 2 in R and 4 in
Pyhton -- depicting blocks and sub-blocks on your code structure) that
can result messy on a shell. Thus, to learn how to create functions
and simple control structures you should create and save documents
(i.e. .r or .py) that we call scripts.

And this is the way computer programs work: you give them some
\emph{statements} (directly or from a script) to which they
react. Statements are just written instructions that are executed by
the console.  We call a sequence of these statements a \emph{computer
  program}. In the previous section, when we created objects or
\emph{variables} (i.e. |a = 100|) we already dealt
with the basic statement, which is called \emph{assignment
  statement}. But the statements can be more complex.
%and include many internal components, such as \emph{assignment statement}, which are
%representations of values that combine variables, constants and
%functions (i.e.  x+1 AND z\textless100). There are some specific
%expressions (such as \emph{lists of comprehension} in Python) that we
%will discuss later, but for now you can notice that by using
%statements, expressions and variables you have the basics for computer
%programming.

Fortunately, we have great syntactic tools to write code. Both, R and
Python have \emph{loops} and \emph{conditional statements}, which will
make your coding journey much easier and with more sophisticated
results because you can control the way your statements are
executed. By controlling the flow of instructions you can deal with a
lot of challenges in computer programming such as iterating over
unlimited cases or executing part of your code as a function of new
inputs.

Firstly, loops are sequences that are executed once, indefinitely or
until a certain condition is reached. This means that you can operate
over a set of objects as many times as you want just by giving one
instruction. The most common types of loops are \emph{for},
\emph{while} and \emph{repeat} (do-while). Letâ€™s understand this
concept by explaining the for-loops. Imagine you have a list of
headlines as an object either on R or Python and you want simple code
to print out the length of each message. Of course you can go headline
by headline using the indexing, but you will get bored or will not
have time enough if you have thousands of cases. Thus, the idea is to
operate a loop in the list so you can get all the results, from the
first until the last element, with just one instruction.  The syntax
of the for-loop in R is:

\begin{verbatim}
for (val in sequence)
{
statement
}
\end{verbatim}

In Python, the syntax of the for-loop is:

\begin{verbatim}
for var in iterable:
    statement(s)
\end{verbatim}


\pyrex[caption=for loops let you repeat operations]{chapter03/forloop}

As \refex{forloop} illustrates, every time you find yourself
\emph{repeating} something, for instance printing each element from a
list, you can get the same results easier by \emph{iterating} or
\emph{looping} over the elements of the list, in this case.  Notice
that you have same results, but with the loop you can automatize your
operation writing few lines of code. As we will stress along this
book, a good practice in coding is to be efficient and harmonious in
the amount of code we write, which is another justification for using
loops.

Another way to iterate in Python is using list comprehensions  (not available natively in R), which are a stylish way to create list of elements automatically even with conditional clauses. This is the syntax:

\begin{verbatim}
newlist  = [expression for item in list if conditional]
\end{verbatim}

In \refex{listcomprehesions} we provide a simple example (without any
conditional clause) that creates a list with the number of characters
of each headline. As this example illustrates, list comprehensions
allow you to essentially write a whole for-loop in one
line. Therefore, list comprehensions are very popular in Python.

\codex[caption=List comprehensions are very popular in Python]{chapter03/listcomprehensions.py}



\subsection{Conditional statements}

Conditional statements will allow you to control the flow and order of
the statements written on your code. This means you can mandate the
machine to do this or that, depending on a given circumstance. These
statements use logic operators to test \emph{if} your condition is met
(True) or not (False) and execute an instruction accordingly. Both in
R and Python, we use the clauses \emph{if}, \emph{else if}
(\emph{elif} in Python) and \emph{else} to write the syntax of the
conditional statements. Let's begin showing you the basic structure of
the conditional statement in R:

\begin{verbatim}
if (condition) {
    Statement1
} else if{
    Statement2
}
else {
    Statement3
}
\end{verbatim}

The syntax in Python is even simpler:

\begin{verbatim}
if condition_1:
    statement_1
elif condition_2:
    statement_2
else:
    statement_3
\end{verbatim}

Imagine you want to print the headlines of \refex{forloop} only if the text is less than 40 characters long. We can include the conditional statement in the loop adding the next code to the script:

\pyrex[caption=A simple conditional control structure, output=py]{chapter03/if1}

We could also make it a bit more complicated: First check whether the length is smaller than 40, then check whether it is exactly 44 (|elif| / |else if|), and finally specify what to do if none of the conditions was met (|else|).

In \refex{if2}, we will print the headline if it is shorter than 40 characters, print the string ``What a surprise!'' if it is exactly 44 characers, and print ``NaN'' in all other cases. 

\pyrex[caption=A more complex conditional control structure, output=py]{chapter03/if2}

Notice that we have included the clause \emph{elif} in the structure (in R it is noted \emph{else if}). \emph{elif} is just another clause which statement must be executed only if an earlier condition was not satisfied. However, the reasoning behind the logic operators remains the same.
