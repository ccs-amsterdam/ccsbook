\newcommand{\fnarrow}{\footnote{In both R and Python, the equals
  sign (\texttt{=}) can be used to assign values. In R, however, the
  traditional way of doing this is using an arrow (\texttt{\textless-}). In
  this book we will use the equals sign for assignment in both
  languages, but remember that for R, \texttt{x = 10} and
  \texttt{x \textless-10} are essentially the same.}}


\section{About objects and data types}
\label{sec:datatypes}

Now that you have seen what R and Python can do in \refchap{fundata},
it is time to take a small step back and learn more about how it all actually works under the hood.
%\footnote{If you have not installed the require software yet and
%  still want to follow this chapter, you may use available online
%  platforms for RStudio (https://rstudio.cloud/) and Python
%  (https://www.python.org/shell/).}.
In both languages, you write a
\emph{script} or \emph{program} containing the commands for the
computer.  But before we get to
some real programming and exciting data analyses, we need to understand
how data can be represented and stored.

No matter whether you use R or Python, both store your data in memory as \emph{objects}.
Each of these objects has a name, and you create them by
assigning a value to a name. For example, the command \texttt{x = 10}
creates a new object\fnarrow, named \texttt{x}, and stores the value 10
in it.  This object is now stored in memory and can be used in later
commands. Objects can be simple values such as the number 10, but they can also
be pieces of text, whole data frames (tables), or analysis results.
We call this distinction the \emph{type} or \emph{class} of an
object. 

\note{A small note on terminology: In programming, a distinction is
  often made between an object (such as the number 10) and the
  variable in which it is stored (such as \texttt{x}). The latter is also called a ``pointer''.
  However, this distinction is not very relevant for most of our
  purposes. Morever, in statistics, the word variable often refers to a
  column of data, rather than to the name of, for instance, the object
  containing the whole data frame (or table).  For that
  reason, we will use the word \emph{object} to refer to both the
  actual object or value and its name. (If you want some extra food
  for thought and want to challenge your brain
  a bit, you can try to see the relationship between the idea of a pointer and
  the discussion about mutable and immutable objects below.)}

Let' create an object that we call |a| (an arbitray name, you can use
whatever you want), assign the value 100 to it, and use the \fn{class}
function (R) or \fn{type} function (Python) to check what kind of
object we created (\refex{var1}).
As you can see, R reports the type of the number as `numeric', while Python reports it
as `int', short for integer or whole number.  Although they use
different names, both languages offer very similar data types.
\reftab{types} provides an overview of some common basic data types.
%As you can see,
%both Python and R have very similar types for simple data such as
%numbers, text, and truth values.

\pyrex[output=both,caption=Determining the type of an object]{chapter03/var1}

\newcommand{\fndouble}{In R, double and numeric can generally be used
  interchangably (there is a subtle difference, but that is not
  relevant here).}

\begin{table}
  \caption{\label{tab:types}Most used basic data types in Python and R}{
  \begin{tabularx}{\textwidth}{lllll}
    \toprule
    \multicolumn{2}{c}{Python} & \multicolumn{2}{c}{R}& Description \\
    \cmidrule(lr){1-2}    \cmidrule(lr){3-4}\\
    Name & Example & Name & Example \\
    \midrule
    int   & \verb+1+             & integer   & \verb+1L+             & whole numbers \\
    float & \verb+1.3+           & numeric   & \verb+1.3+           & numbers with decimals \\
    str   & \verb+"Spam", 'ham'+ & character & \verb+"Spam", 'ham'+ & textual data  \\ 
    bool  & \verb+True, False+   & logical   & \verb+TRUE, FALSE+   & the truth values \\
    \bottomrule
  \end{tabularx}}{}
\end{table}
    


Let's have a closer look at the code in \refex{var1}.
The first line is a command to create the object \emph{a} and store
its value 100; and the second is illustrative and will give you the
class of the created object, in this case ``numeric''. Notice that we
are using two native functions of R, \fn{print} and \fn{class}, and
including |a| as an argument of \fn{class}, and the very same
\fn{class(a)} as an argument of \fn{print}. The only difference
between R and Python, here, is that the relevant Python function is
called \fn{type} instead of \fn{class}.

Once created, you can now perform multiple operations
with |a| and other values or new variables. For example, you
could transform |a| by multiplying |a| by 2, create a new
variable |b| of value 50 and then create another new object
|c| with the result of |a + b| (\refex{var2}).

\pyrex[output=both,caption=Some simple operations]{chapter03/var2}




\subsection{Storing single values: integers, floating-point numbers, booleans}

When working with numbers, we distinguish between integers (whole
numbers) and floating point numbers (numbers with a decimal point,
called `numeric' in R). Both Python and R automatically determine the
data type when creating an object, but differ in their default
behavior when storing a number that can be represented as an int: R
will store it as float anyway and you need to force it to do
otherwise, for Python it is the other way round
(\refex{var3}). We can also convert between types later on,
even though converting a float to an int might not be a too good idea,
as you truncate your data.

So why not just always use a float? First,
floating point operations usually take more time than integer operations.
Second, because floating point numbers are stored as a combination of
a coefficient and an exponent (to the base of 2), many integers (or,
in fact, many decimal fractions) can only approximately be stored
as a floating point number. Except for specific domains (such
as finance), these inaccuracies are often not of much practical importance.
But it explains why calculating |6*6/10| in Python returns 3.6, while
|6*0.6| or |6*(6/10)| returns 3.5999999999999996. Therefore, if
a value can logically only be a whole number (anything that is
countable, in fact), it makes sense to restrict it to an integer.

We also have a data type that is even more restricted and can take
only two values: true or false. It is called `logical' (R) or `bool'
(Python).  Just notice that Boolean values are case sensitive:
while in R you must capitalize the whole value (|TRUE|, |FALSE|), in
Python we only capitalize the first letter: |True|, |False|.  As you can
see in \refex{var3}, such an object behaves exactly as an integer that
is only allowed to be 0 or 1, and it can easily be converted to an
integer.

\pyrex[caption={Floating point numbers, integers, and boolean values}]{chapter03/var3}




\subsection{Storing text}

As a computational analyst of communication you will usually work with
text objects or strings of characters. Commonly simply known as ``strings'',
such text objects are also referred to as ``character vector objects'' in R.
You can create them just by adding single or double quotes around the value of the variable (keep in mind to begin and finish the string either with single or with double quotes, and not to mix their use). Every time you want to analyze a social-media message, or any other text, you will be dealing with such strings. 

\begin{ccsexample}
  \doublecodex{chapter03/var4}
  \doubleoutput{chapter03/var4}
  \doublecodex{chapter03/var4b}
  \doubleoutput{chapter03/var4b}
  \caption{Strings and bytes}\label{ex:var4}
 \end{ccsexample}

As you see in \refex{var4}, you can create a string by enclosing a text in quotation
marks. You can use either double or single quotation marks, but you
need to use the same mark to begin and end the string. This can be
useful if you want to use quotation marks within a string, then you can
use the other type to denote the beginning and end of the string.
If you need to use a single single quotation mark within a single-quoted string,
you can \concept{escape} the quotation mark by prepending it with a backslash (\verb|\'|),
and similarly for double-quoted strings.
To include an actual backslash in a text, you also escape it with a backslash,
so you end up with a double backslash (\verb|\\|). 

The Python example also shows a concept introduced in Python 3.6 (introduced in December 2016):
the f-string.  These are strings that are prefixed with the letter \texttt{f} and are \emph{formatted} strings. This means that these strings will automatically insert a value were curly brackets indicate you wish to do so. This means that you can write: \texttt{print(f'The value of i is \{i\}'} to print ``The value of i is 5'', given that i is 5.
In R, the \pkg{glue} package allows you to use a f-string-like syntax as well: \texttt{glue("The value of i is \{i\}")}.

Although this will be explained in more detail in \refsec{unicode},
it is good to introduce how computers store text in memory or files. 
It is not too difficult to imagine how a computer internally
handles \emph{integers}: After all, even though the number may be displayed
as a decimal number to us, it can be trivially converted and stored
as a binary number (effectively, a series of zeros and ones)
--- we do not have to care about that.
But when we think about text, it is not
immediately obvious how a string should be stored as a sequence of
zeros and ones, especially given the huge variety of writing systems used for different languages. 

Indeed, there are several ways of how textual characters can be stored as bytes,
which are called \concept{encodings}. 
The process of moving from bytes (numbers) to characters is called decoding,
and the reverse process is called encoding. 
Ideally, this is not something you should need to think of,
and indeed strings (or character vectors) already represent decoded text.
This means that often when you read from or write data to a file,
you need to specify the encoding (usally UTF-8). 
However, both Python and R also allow you to work with the raw data
(e.g. before decoding) in the form of \concept{bytes} (Python) or \concept{raw} (R) data,
which is sometimes necessary if there are encoding problems.
This is shown briefly in the bottom part of \refex{var4}.
Note that while R shows the underlying hexadecimal byte values of the raw data (so 54 is \verb|T|, 68 is \verb|h| and so on) and Python displays the bytes as text characters, in both cases the underlying data type is the same: raw (non-decoded) bytes.



\subsection{Combining multiple values: lists, vectors, and friends}

Until now, we have focused on the basic, inital datatypes or ``vector
objects'', as they are called in R.  Often, however, we want to group
multiple of these objects. For example, we do not want to manually
create thousands of objects called tweet0001, tweet0002, \ldots,
tweet9999 -- we'd rather have one list called tweets that contains all
of them. You will encounter several names for such combined data
structures: lists, vectors, arrays, series, and some
more. 
The core idea is always the same: we take multiple objects
(be it numbers, strings, or anything else) and then create one object that combines all of them (\refex{1darray1}).

\pyrex[caption=Collections arrays (such as vectors in R or lists in Python) can contain multiple values]{chapter03/1darray1}

As you see, we now have one name (such as |scores|) to refer to all of scores.
The Python object in \refex{1darray1} is called a \emph{list}, the R object a \emph{vector}.
There are more of such combined data types, which have slightly different
properties that can be important to know about: First, whether you can mix different
types (say, integers and strings); second, what happens if you change the array.
We will discuss both points below and show how this relates to different
specific types of arrays in Python and R which you can choose from. But first,
we will show how to work with them.


\paragraph{Operations on vectors and lists}
One of the most
basic operations you can perform on all types of one-dimensional arrays
is \emph{indexing}. It lets you locate any given
element or group of elements within a vector using its or their
positions. The first item of a vector in R is called 1, the second 2, and so on;
in Python, we begin counting with 0.  You can retrieve a specific element
from a vector or list by simply putting the index between square brackets |[]| (\refex{1darray2}). %In \refex{1darray2}, we
%start with an array of scores that are abusively stored as string,
%retrieve some of these values, and finally convert them to integers.

\pyrex[input=both, output=both, caption=Slicing vectors and converting data types]{chapter03/1darray2}

In the first case, we asked for the score of the 5th student ("9");
in the second we asked for the 1st and 10th position ("8" "5"); and
finally for all the elements between the 1st and 4th position ("8"
"8" "7" "6"). We can directly indicate a range
by using a |:|. After the colon, we provide the index of
the last element (in R), while Python stops just \emph{before} the index.\footnote{This is related to the
reason why Python starts counting with zero. If you are intetested
in this, have a look at \url{https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html}}
If we want to pass multiple single index values instead of a range,
we need to create a vector of these indices by using |c()| (\refex{1darray2}).
Take a moment to compare the different ways of indexing between Python
and R in \refex{1darray2}!

Indexing is very useful to access elements and also to
create new objects from a part of another one. The last line of our
example shows how to create a new array with just the first four
entries of |scores| and store them all as numbers. To do so, we
use \emph{slicing} to get the first four scores and then either change its class using the function
as.numeric (in R) or convert the elements to integers one-by-one (Python)  (\refex{1darray2}).


\pyrex[input=both, output=none, caption=Some more operations on one-dimensional arrays]{chapter03/1darray3}

We can do many other things like adding or removing values, or creating a vector from scratch by using a
function (\refex{1darray3}). For instance, rather than just typing over a lot of values by hand, we often might
wish to create a vector from an operator or a function, without typing
each value. Using the operator \fn{:} (R) or the functions \fn{seq} (R) or \fn{range} (Python), we can create numeric vectors with
a range of numbers.%, from 1 to 20 or from -5 to 5 (\refex{1darray3}).
%You can also use a function to create more complex vectors. For
%example the function \fn{seq} will help you to generate regular sequences
%by providing the number of points of an interval.  Imagine you want to
%create a numeric vector than begins in point 0 and finishes in point
%1, including all possible values that separate those two points by a
%step of 0.2. Let's create that vector and check the amount of created
%elements by using the function \fn{length} (\refex{1darray3}).



\paragraph{Can we mix different types?}
There is a reason that the basic datatypes (numeric, character, etc.) we described above are called
``vector objects'' in R: The vector is a very important structure in
R and consists of these objects. A vector can be easily created with the
\fn{c} function and can only combine elements of the same type (numeric, integer, complex,
character, logical, raw).
Because the data types within a vector correspond to only one class,
when we create a vector with the scores of a class of 10 students, or a character vector of
three countries, as we do in \refex{1darray1}), R's \fn{class} function will display
``numeric'' or ``character'', and not ``vector'', as one may assume.

If we try to
create a vector with two different data types, R will 
force some elements to be transformed, so that all elements belong to the same
class. For example, if you re-build the vector of scores with a new student who has
been graded with the letter \emph{b} instead of a number (\refex{1darray1b}, your vector
will become a character vector. If you print it, you will see that the
values are now displayed surrounded by |"|.


\pyrex[caption=R enforces that all elements of a vector have the same data type, output=r, input=r]{chapter03/1darray1b}


In contrast to a vector, a \concept{list} is much less restricted: A list does not care
whether you mix numbers and text. In Python, such lists are the most common type for creating
a one-dimensional array. Because they
can contain very different objects, running the \fn{type} function on them
does not return anything about the objects inside the list, but simply states that we
are dealing with a list (\refex{1darray1}).
In fact, lists can even contain other lists, or any other object for
that matter.

In R you can also uses lists, even though they are much less popular in R than
they are in Python because vectors are better if all objects are of the same type.
R lists are created in a similar way as vectors, except that we have to add the word |list|
before declaring the values. Let's build a list with four different
kind of elements, a numeric object, a character object, a square root
function (\fn{sqrt}) and a numeric vector (\refex{1darray4}). In fact, you
can use any of the elements in the list through indexing -- even the
function \fn{sqrt} that you stored in there to get the square root of
16!

\pyrex[input=both, output=both, caption=Lists can store very different objects of multiple data types and even functions]{chapter03/1darray4}

Python users often like that lists give  a lot of flexibility, as they happily accept
entries of very different types. But also Python users sometimes may want a stricter
structure like R's vector. This may be especially interesting for
high-performance calculations, and therefore, such a structure is
avalable from the \pkg{numpy} (\emph{num}bers in \emph{py}thon)
package: the numpy array.
This will be discussed in more detail when we deal with data frames in \refchap{filetodata}.

%\pyrex[input=py, output=py, caption={Numpy arrays behave more like R vectors. However, you have to import (and potentially install) an additional package, \pkg{numpy}, for this (see \refsec{installing})}]{chapter03/1darray7}

\begin{feature}\textbf{Object references and mutable objects}
  A subtle difference between Python and R is how they deal with copying objects.
  Suppose we define $x$ containing the numbers $1,2,3$ (\verb|x=[1,2,3]| in Python or \verb|x=c(1,2,3)| in R)
  and then define an object y to equal x (\verb|y=x|).
  In R, both objects are kept separate, so changing $x$ does not affect $y$,
  which is probably what you expect.
  In Python, however, we now have two variables (names) that both point to or \concept{reference} the same object,
  and if we change $x$ we also change $y$ and vice versa, which can be quite unexpected.
  Note that if you really want to copy an object in Python, you can run \verb|x.copy()|.
  See \refex{mutable} for an example.

  Note that this is only important for \concept{mutable} objects, that is,
  objects that can be changed.
  For example, lists in Python and R and vectors in R are mutable because you can replace or append members.
  Strings and numbers, on the other hand, are immutable:
  you cannot change a number or string, a statement such as \verb|x=x*2| creates a new object containing the value of \verb|x*2| and stores it under the name \verb|x|.

\end{feature}
  
\pyrex[caption={The (unexpected) behavior of mutable objects}]{chapter03/mutable}

\paragraph{Sets and Tuples}
The \fn{vector} (R) and \fn{list} (Python) are the most frequently used collections
for storing multiple objects. 
In Python there are two more collection types you are likely to encounter.
First, \concept{tuples} are very similar to lists, but they cannot be changed after creating them
(they are \concept{immutable}).
You can create a tuple by replacing the square brackets by regular parentheses:
\verb|x=(1,2,3)|. 

Second, in Python there is an object type called a \concept{set}.
A set is a mutable collection of \emph{unique} elements (you cannot repeat a value) with
no order. As it is not properly ordered, you cannot run any indexing
or slicing operation on it.
Although R does not have an explicit set type,
it does have functions for the various set operations,
the most useful of which is probably the function \fn{unique} which removes all duplicate values in a vector.
\refex{sets} shows a number of set operations in Python and R,
which can be very useful for e.g. finding all elements that occur in two lists.

\pyrex[input=both, output=both, caption={Sets}]{chapter03/sets}


%Beyond the class (which is a powerful function because you can create new classes your self), you can also get the R internal type of the object (storage mode), using the typeof() function:
%\begin{exampler}
%typeof(scores)
%\end{exampler}


%% \paragraph{Factors}

%% Finally, a data structure similar to a vector is the \fn{factor}.
%% R users are very likely tp encounter factors, which can be very useful when
%% working with categorical data. Factors
%% store the values of a vector with corresponding labels.%, which in
%% turn will produce levels.
%% If you create a factor, it will
%% automatically read the labels from the values of the vector, but you
%% may manually change those levels. Let's have a look at
%% \refex{1darray6}.  The first line will create again a vector of scores
%% of ten students. Then we automatically convert the vector into a
%% factor (reading the very same values as labels) and finally we create
%% the labels (``fail" or ``pass") for each of the possible grades.  The
%% factor-type object factor\_scores\_2 will be probably more useful to
%% deal with a bigger amount of students. While we have only two levels
%% (which can be identified with the function \fn{nlevels}), we can have many
%% values to connect with those labels.

%% \pyrex[input=r, output=none, caption=Factors can also store labels]{chapter03/1darray6}

%% Python does not natively support factors. The \pkg{pandas} library,
%% which we will use later throught this book, introduces a datatype called
%% \fn{Categorical} that serves the same purpose, but it is much less
%% used than factors are in R.



\subsection{Dictionaries}

Python \emph{dictionaries} are a very powerful and versatile data type.
Dictionaries contain unordered and mutable collections of objects that
contain certain information in another object. Python generates this
data type in form of |{key : value}| pairs in order
to map any object by its key and not by its relative position in the
collection. Unlike in a list, in which you index with an integer denoting
the position in a list, you can index a dictionary using the key.
For example, in \refex{dict}, we want to get the values of the object 'positive' in the
dictionary \emph{sentiments} and of the object 'A' in the dictionary
\emph{grades}.You will
find dictionaries very useful in your journey as a computational
scientist or practitioner, since they are flexible ways to store and
retrieve structured information. We can create them using the curly
brackets {} and including each key-value pair as an element of the
collection (\refex{dict}).

In R, the closest you can get to a Python dictionary is to use lists with named elements.
This allows you to assign and retrieve values by key,
however the key is restricted to names, while in Python most objects can be used as keys.
You create a named list with \verb|d = list(name=value)| and access individual elements with either
\verb|d$name| or \verb|d[["name"]]|. 

\pyrex[caption=Key-value pairs in Python dictionaries and R named lists]{chapter03/dict}

A good analogy for a dictionary is a telephone book (imagine a paper
one, but it actually often holds true for digital phone books as
well): The names are the keys, and the associated phone numbers the
values. If you know someone's name (the key), it is \emph{very easy}
to look up the corresponding values: even in a phone book of thousands
of pages, it takes you maybe 10 or 20 seconds to look up the name
(key). But if you know someone's phone number (the value) instead and
want to look up the name, that's very inefficient: you need to read
the whole phone book until you find the number.

Just as the elements of a list can be of \emph{any} type, and you can
have lists of lists, you can also nest dictionaries to get dicts of
dicts. Think of our phone book example: rather than storing just a
phone number as value, we could store another dict with the keys
'office phone', 'mobile phone', etc. This is very often done, and you
will come across many examples dealing with such data structures.
You have one restriction, though: the keys in a dictionary (as opposed
to the values) are not allowed to be mutable. After all, imagine that
you could use a list as a key in a dictionary, and if at the same time,
some other pointer to that very same list could just change it, this
would lead to a quite confusing situation.




\subsection{From 1D to 2D (and higher): matrices and $n$-dimensional arrays}

Matrices are two-dimensional rectangular data sets that include values
in rows and columns. This is the kind of data you will have to deal
with in many analyses shown in this book, such as those related to
machine learning. Often, we can generalize to higher dimensions.

\pyrex[caption=Working with two- or $n$-dimensional arrays, output=both]{chapter03/2darray}

In Python, the easiest representation is to simply construct a list of
lists. This is, in fact, often done, but has the disadvantage that
there are no easy ways to get, for instance, the dimensions (the
shape) of the table, or to print it in a neat(-er) format. To get all
that, one can transform the list of list into an |array|, a
datastructure provided by the package \pkg{numpy}.

To create a matrix in R, you have to use the function \fn{matrix} and
create a vector of values with the indication of how many rows and
columns will be on it. We also have to tell R if the order of the
values is determined by the row or not. In \refex{2darray}, we create
two matrices in which we vary the |byrow| argument to be TRUE and
FALSE, respectively, to illustrate how it changes the values of the
matrix, even when the shape (2x3) remains identical. As you may
imagine, we can operate with matrices, such as adding up two of them.

%% A powerful data type are the arrays (very much like the \pkg{numpy}
%% arrays described above), which might be similar to matrices but
%% without the restriction of the two-dimensional rectangular space. This
%% means that you create your own dimensions, indicating (in order) the
%% number of rows, columns and matrices of the array. Your will need
%% vectors as inputs and dimensions as parameters. For example,
%% three-dimensional arrays are fundamental when writing pixel values and
%% coding images. 


\subsection{Making life easier: data frames}

So far, we have discussed the general built-in collections that you find in most programming languages
such as the list and array.
However, in data science and statistics you are very likely to encounter a specific collection type that we haven't discussed yet: the \concept{Data frame}.
These structures are discussed in detail in \refchap{filetodata},
but for completeness we will also introduce them briefly here. 

Data frames are user-friendly data structures that look very much like
what you find in SPSS, Stata, or Excel. They will help you in a wide
range of statistical analysis.  A
data frame is a tabular data object that includes rows (usually the
instances or cases) and columns (the variables). In a three-column data frame,
the first variable can be \emph{numeric}, the second \emph{character}
and the third \emph{logical}, but the important thing is that each
variable is a vector and that all these vectors must be of the same
length. We create data frames from scratch using the data.frame()
function.  Letâ€™s generate a simple data frame of three instances (each
case is an author of this book) and three variables of the types
numeric (\emph{age}), character (\emph{country} where he obtained his
master degree) and logic (\emph{living abroad}, wether he currently
lives out of his born country) (\refex{dataframe1}).
Notice that you have the label of the variables at the top of each column and that it creates an automatic numbering for indexing the rows.  

\pyrex[caption=Creating a simple dataframe,output=py]{chapter03/dataframe1}
