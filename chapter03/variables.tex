\newcommand{\fnarrow}{\footnote{In both R and Python, the equals
  sign (\texttt{=}) can be used to assign values. In R, however, the
  traditional way of doing this is using an arrow (\texttt{\textless-}). In
  this book we will use the equals sign for assignment in both
  languages, but remember that for R, \texttt{x = 10} and
  \texttt{x \textless-10} are essentially the same.}}


\section{About objects and data types}
\label{sec:datatypes}

Now that you can run R and Python, we
can move on to the basics of data analysis in R and
Python\footnote{If you have not installed the require software yet and
  still want to follow this chapter, you may use available online
  platforms for RStudio (https://rstudio.cloud/) and Python
  (https://www.python.org/shell/).}.  In both languages, you write a
\emph{script} or \emph{program} containing the commands for the
computer.  But before we get to
some real programming and exciting data analyses, we need to understand
how data can be represented and stored.

No matter whether you use R or Python, both store your data in memory as \emph{objects}.
Each of these objects has a name, and you create them by
assigning a value to a name. For example, the command \texttt{x = 10}
creates a new object\fnarrow, named \texttt{x}, and stores the value 10
in it.  This object is now stored in memory and can be used in later
commands. Objects can be simple values such as the number 10, but they can also
be pieces of text, whole data frames (tables), or analysis results.
We call this distinction the \emph{type} or \emph{class} of an
object. 

\note{A small note on terminology: In programming, a distinction is
  often made between an object (such as the number 10) and the
  variable in which it is store (such as \texttt{x}). The latter is also called a ``pointer''.
  However, this distinction is not very relevant for most of our
  purposes. Morever, in statistics, the word variable often refers to a
  column of data, rather than to the name of, for instance, the object
  containing the whole data frame (or table).  For that
  reason, we will use the word \emph{object} to refer to both the
  actual object or value and its name. (If you want some extra food
  for thought and want to challenge your brain
  a bit, you can try to see the relationship between the idea of a pointer and
  the discussion about mutable and immutable objects below.)}

Let' create an object that we call |a| (an arbitray name, you can use
whatever you want), assign the value 100 to it, and use the \fn{class}
function (R) or \fn{type} function (Python) to check what kind of
object we created (see \refex{var1}).
As you can see, R reports the type of the number as `numeric', while Python reports it
as `int', short for integer or whole number.  Although they use
different names, both languages offer very similar data types.
\reftab{types} provides an overview of some common basic data types.
%As you can see,
%both Python and R have very similar types for simple data such as
%numbers, text, and truth values.

\pyrex[output=both,caption=Determining the type of an object]{chapter03/var1}

\newcommand{\fndouble}{In R, double and numeric can generally be used
  interchangably (there is a subtle difference, but that is not
  relevant here).}

\begin{table}
  \caption{\label{tab:types}Most used data types in python and R}{
  \begin{tabularx}{\textwidth}{lllll}
    \toprule
    \multicolumn{2}{c}{Python} & \multicolumn{2}{c}{R}& Description \\
    \cmidrule(lr){1-2}    \cmidrule(lr){3-4}\\
    Name & Example & Name & Example \\
    \midrule
    int   & \verb+1+             & integer   & \verb+1L+             & whole numbers \\
    float & \verb+1.3+           & numeric   & \verb+1.3+           & numbers with decimals \\
    str   & \verb+"Spam", 'ham'+ & character & \verb+"Spam", 'ham'+ & textual data  \\ 
    bool  & \verb+True, False+   & logical   & \verb+TRUE, FALSE+   & the truth values \\
    \bottomrule
  \end{tabularx}}{}
\end{table}
    


Let's have a closer look at the code in \refex{var1}.
The first line is mandatory to create the object \emph{a} and store
its value 100; and the second is illustrative and will give you the
class of the created object, in this case ``numeric''. Notice that we
are using two native functions of R, \fn{print} and \fn{class}, and
including |a| as an argument of \fn{class}, and the very same
\fn{class(a)} as an argument of \fn{print}. The only difference
between R and Python, here, is that the relevant Python function is
called \fn{type} instead of \fn{class}.

Once created, you can now perform multiple operations
with |a| and other values or new variables. For example, you
could transform |a| by multiplying |a| by 2, create a new
variable |b| of value 50 and then create another new object
|c| with the result of |a + b| (\refex{var2}).

\pyrex[output=both,caption=Some simple operations]{chapter03/var2}




\subsection{Storing single values: integers, floating-point numbers, booleans}

When working with numbers, we distinguish between integers (whole
numbers) and floating point numbers (numbers with a decimal point,
called `numeric' in R). Both Python and R automatically determine the
data type when creating an object, but differ in their default
behavior when storing a number that can be represented as an int: R
will store it as float anyway and you need to force it to do
otherwise, for Python it is the other way round
(\refex{var3}). We can also convert between types later on,
even though converting a float to an int might not be a too good idea,
as you truncate your data.

So why not just always use a float? First,
floating point operations usually take more time than integer operations.
Second, because floating point numbers are stored as a combination of
a coefficient and an exponent (to the base of 2), many integers (or,
in fact, many decimal fractions) can only approximately be stored
as a floating point number. Except for specific domains (such
as finance), these inaccuracies are often not of much practical importance.
But it explains why calculating |6*6/10| in Python returns 3.6, while
|6*0.6| or |6*(6/10)| returns 3.5999999999999996. Therefore, if
a value can logically only be a whole number (anything that is
countable, in fact), it makes sense to restrict it to an integer.

We also have a data type that is even more restricted and can take
only two values: true or false. It is called `logical' (R) or `bool'
(Python).  Just notice that Boolean values are case sensitive:
while in R you must capitalize the whole value (|TRUE|, |FALSE|), in
Python we only capitalize the first letter: |True|, |False|.  As you can
see in \refex{var3}, such an object behaves exactly as an integer that
is only allowed to be 0 or 1, and it can easily be converted to an
integer.

\pyrex[caption={Floating point numbers, integers, and boolean values}]{chapter03/var3}




\subsection{Storing text}

As a computational analyst of communication you will usually work with
text objects or strings of characters. Commonly simply known as ``strings'',
such text objects are also referred to as ``character vector objects'' in R.
You can create them just by adding single or double quotes around the value of the variable (keep in mind to begin and finish the string either with single or with double quotes, and not to mix their use). Every time you want to analyse a social-media message, or any other text, you will be dealing with such strings. 

\pyrex[caption=Strings and bytes]{chapter03/var4}

It is not too difficult to imagine how a computer internally
handles \emph{integers}: After all, even though the number may be displayed
as a decimal number to us, it can be trivially converted and stored
as a binary number (effectively, a series of zeros and ones)
--- we do not have to care about that, as there
is only one way of doing so. But when we think about text, it is not
immediately obvious how a string should be stored as a sequence of
zeros and ones.
Indeed, here are several ways of how textual characters can be stored as
bytes, and it is important to be aware of this.
Although you will not encounter this too often, sometimes
we even have to process raw bytes. Quite confusingly, bytes are also often
displayed as letters, but they are different: To begin with, a byte
only has $2^8=256$ possible values, while there are more than one
million possible characters that can form one character in a
string, especially in the case of so-called Unicode strings, which may contain letters
from scripts from all around the world or also emojis.
You can read more about this in
\refsec{encodings}.  Because we ocasionally need a low-level approach in which we care about the exact
bytes underlying a string,  \refex{var4} shows how to create both normal strings and raw
(byte) strings. Nowadays, you seldom have to 
create raw byte strings.  Historically, that was different. For instance,
in Python 2, strings by default were considered raw byte strings
Still, data from some legacy software or data you retrieve from 
some online sources may still come in as raw bytes (see \refchap{scraping}).

As you see in \refex{var4}, a string is denoted by quotation
marks. You can use either double or single quotation marks, but you
need to use the same mark to begin and end the string. This can be
useful if you want to use quotation marks within a string, then you can
use the other type to denote the beginning and end of the string.

\note{Since Python 3.6, there is a new type of string, the f-string. These are strings that are prefixed with the letter \texttt{f} and are \emph{formatted} strings. This means that these strings will automatically insert a value were curly brackets indicate you wish to do so. This means that you can write: \texttt{print(f'The value of i is \{i\}'} to print ``The value of i is 5'', given that i is 5. In a similar fashion, you can prevent Python from interpreting special characters by prefixing the string with the letter \texttt{r}, which can be useful when writing regular expressions (\refsec{regular}). In R, the \pkg{glue} package allows you to use a f-string-like syntax as well.}


\subsection{Combining multiple values: lists, vectors, and friends}

Until now, we have focused on the basic, inital datatypes or ``vector
objects'', as they are called in R.  Often, however, we want to group
multiple of these objects. For example, we do not want to manually
create thousands of objects called tweet0001, tweet0002, \ldots
tweet9999 -- we'd rather have one list called tweets that contains all
of them. You will encounter several names for such combined data
structures: lists, vectors, one-dimensional arrays, series, and some
more. 
The core idea is always the same: we take multiple objects
(be it numbers, strings, or anything else) and then create one object that combines all of them (\refex{1darray1}).

%\begin{table}[ht]
%\label{tab:vector_objects}
%\caption{Classes of vector objects in R\label{table:nonlin}}{%
%\centering
%\begin{tabular}{c c c p{2cm}}
%\hline\hline
%Data type & Example & Code \\ [0.5ex]
%\hline
%Numeric&1, 2.5, 100, 2500.38& a = 100 \\
%Integer&20L, 100L&d = 20L \\
%Complex& 100+50x, 8*3i &e = 100+50x \\
%Character&   \parbox[t]{4cm}{\centering 'a', "I am happy learning R!!!", "200", 'R', "FALSE"} & tweet  = "I am happy learning R!!!" \\
%Raw& \parbox[t]{4cm}{\centering "Any text" stored as:  41 6e 79 20 74 65 78 74} & raw\_string  = charToRaw("Any text") \\
%Logical& TRUE, FALSE & logical\_operator  = TRUE  \\ [1ex]
%\hline
%\end{tabular}}{}
%\end{table}


%Table~\ref{tab:vector_objects} summarizes vector objects available in R.


\pyrex[caption=One-dimensional arrays (such as vectors in R or lists in Python) can contain multiple values, output=both, input=both]{chapter03/1darray1}

%|tweets = ["this is some tweet", "yet another tweet", "and a third one"]| (Python) or
%|tweets  = c("this is some tweet", "yet another tweet", "and a third one")| (R).

As you see, we now have one name (such as |scores|) to refer to all of scores.
The Python object in \refex{1darray1} is called a \emph{list}, the R object a \emph{vector}.
There are more of such combined data types, which have slightly different
properties that can be important to know about: First, whether you can mix different
types (say, integers and strings); second, what happens if you change the array.
We will discuss both points below and show how this relates to different
specific types of arrays in Python and R which you can choose from. But first,
we will show how to work with them.


\paragraph{Operations on vectors and lists}
One of the most
basic operations you can perform on all types of one-dimensional arrays
is \emph{indexing}. It lets you locate any given
element or group of elements within a vector using its or their
positions. The first item of a vector in R is called 1, the second 2, and so on;
in Python, we begin counting with 0.  You can retrieve a specific element
from a vector or list by simply putting the index between square brackets |[]| (\refex{1darray2}). %In \refex{1darray2}, we
%start with an array of scores that are abusively stored as string,
%retrieve some of these values, and finally convert them to integers.

\pyrex[input=both, output=both, caption=Slicing vectors and converting data types]{chapter03/1darray2}

In the first case, we asked for the score of the 5th student ("9");
in the second we asked for the 1st and 10th position ("8" "5"); and
finally for all the elements between the 1st and 4th position ("8"
"8" "7" "6"). We can directly indicate a range
by using a |:|. After the colon, we provide the index of
the last element (in R), while Python stops just \emph{before} the index.\footnote{This is related to the
reason why Python starts counting with zero. If you are intetested
in this, have a look at \url{https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html}}
If we want to pass multiple single index values instead of a range,
we need to create a vector of these indices by using |c()| (\refex{1darray2}).
Take a moment to compare the different ways of indexing between Python
and R in \refex{1darray2}!

Indexing is very useful to access elements and also to
create new objects from a part of another one. The last line of our
example shows how to create a new array with just the first four
entries of |scores| and store them all as numbers. To do so, we
use \emph{slicing} to get the first four scores and then either change its class using the function
as.numeric (in R) or convert the elements to integers one-by-one (Python)  (\refex{1darray2}).


\pyrex[input=both, output=none, caption=Some more operations on one-dimensional arrays]{chapter03/1darray3}

We can do many other things like adding or removing values, or creating a vector from scratch by using a
function (\refex{1darray3}). For instance, rather than just typing over a lot of values by hand, we often might
wish to create a vector from an operator or a function, without typing
each value. Using the operator \fn{:} (R) or the functions \fn{seq} (R) or \fn{range} (Python), we can create numeric vectors with
a range of numbers.%, from 1 to 20 or from -5 to 5 (\refex{1darray3}).
%You can also use a function to create more complex vectors. For
%example the function \fn{seq} will help you to generate regular sequences
%by providing the number of points of an interval.  Imagine you want to
%create a numeric vector than begins in point 0 and finishes in point
%1, including all possible values that separate those two points by a
%step of 0.2. Let's create that vector and check the amount of created
%elements by using the function \fn{length} (\refex{1darray3}).



\paragraph{Can we mix different types?}
There is a reason that the basic datatypes (numeric, character, etc.) we described above are called
``vector objects'' in R: The vector is a very important structure in
R and consists of these objects. A vector can be easily created with the
\fn{c} function and can only combine elements of the same type (numeric, integer, complex,
character, logical, raw).
Because the data types within a vector correspond to only one class,
when we create a vector with the scores of a class of 10 students, or a character vector of
three countries, as we do in \refex{1darray1}), R's \fn{class} function will display
``numeric'' or ``character'', and not ``vector'', as one may assume.

If we try to
create a vector with two different data types, R will 
force some elements to be transformed, so that all elements belong to the same
class. For example, if you re-build the vector of scores with a new student who has
been graded with the letter \emph{b} instead of a number (\refex{1darray1b}, your vector
will become a character vector. If you print it, you will see that the
values are now displayed surrounded by |"|.


\pyrex[caption=R enforces that all elements of a vector have the same data type, output=r, input=r]{chapter03/1darray1b}


In contrast to a vector, a \emph{list} is much less restricted: A list does not care
whether you mix numbers and text. In Python, such lists are the most common type for creating
a one-dimensional array. Because they
can contain very different objects, running the \fn{type} function on them
does not return anything about the objects inside the list, but simply states that we
are dealing with a list (\refex{1darray1}).
In fact, lists can even contain other lists, or any other object for
that matter. 
Also in R, you can create lists, even though they are much less popular in R than
they are in Python. R lists are created in a similar way as vectors, except that we have to add the word |list|
before declaring the values. Let's build a list with four different
kind of elements, a numeric object, a character object, a square root
function (\fn{sqrt}) and a numeric vector (\refex{1darray4}). In fact, you
can use any of the elements in the list through indexing -- even the
function \fn{sqrt} that you stored in there to get the square root of
16!

\pyrex[input=both, output=both, caption=Lists can store very different objects of multiple data types and even functions]{chapter03/1darray4}

Python users often like that lists give  a lot of flexibility, as they happily accept
entries of very different types. But also Python users sometimes may want a stricter
structure like R's vector. This may be especially interesting for
high-performance calculations, and therefore, such a structure is
avalable from the \pkg{numpy} (\emph{num}bers in \emph{py}thon)
package: the numpy array (\refex{1darray7}).

\pyrex[input=py, output=py, caption={Numpy arrays behave more like R vectors. However, you have to import (and potentially install) an additional package, \pkg{numpy}, for this (see \refsec{installing})}]{chapter03/1darray7}



\paragraph{Mutable versus immutable objects}

Another difference between lists and vectors is less obvious than
the question whether they can contain different data types, is what happens when you try to change them.
Let's take a step back first and think about what happens when assigning values
and names.
Imagine we assigned the name |a| to a value, say 42.
There are two possibilities that could happen when we later on say that |a|,
instead, should be 65. \emph{Either} a new object is created and the name |a|
now points to that new object instead; or the object itself is changed.
The first behavior is called \emph{immutable}, then second \emph{mutable}.
R objects in principle are \emph{immutable}, and so are many types
in Python (e.g., int, float, bool, string). But Python lists are \emph{mutable}.

\note{While most of the time, you will not care about mutable or
  immutable objects, the fact that Python lists (and, later, data frames) are
  mutable can be really crucial if you. \refex{mutable} illustrates
  what happens if you create a new object referring to a mutable
  object, which -- in contrast to what you may think -- does not
  create a copy of the object itself. Rather, we now get two names for
  the same object.}

\pyrex[input=py, output=py, caption={The (for many unexpected) behavior of mutable objects}]{chapter03/mutable}

Why is this important for you? First, because it may cause some
unexpected behavior (see box above); second, it means that you can
choose between creating a mutable list and her immutable sister, the \emph{tuple}.
As you know by now, we build a Python list object using square brackets |[]|. If we use
parentheses |()| instead, we create a tuple. It's as simple as that.
There is not much of a difference between lists and tuples, except that tyuples are immutable, which means that
they are constant or unchangeable and you can not freely change their
values.

In \refex{1darray5}, we create a list and a tuple, and get their sizes with the native function \fn{len}.
We have created two sequences of six objects
(three integers and three strings) that represent common numeric and
categorical values for sentiment analysis. The first sequence is a
list and the second a tuple. We can get any value of the list or tuple
by indexing its position, just keep in mind that indexing in Python
begins in 0 and not in 1 like in R. 

\pyrex[input=py, output=py, caption=Lists and tuples in Python]{chapter03/1darray5}

Imagine now that you decide that the value `neutral' should be
substituted by the value `informative' in the created sequences. You
can update them by just assigning a new value to an item that is
identified by its index.  The list will be correctly updated, but the
code you run to change the tuple will give you an error (with some
message such as: "'tuple' object does not support item
assignment"). The immutability of tuples can be of advantage if you
want to make sure that a value is not accidentily changed.

We also have another Python object called a \emph{set}. A set is a mutable
collection of \emph{unique} elements (you cannot repeat a value) with
no order. As it is not properly ordered, you cannot run any indexing
or slicing operation on it. The immutable version of sets are called
frozensets.

\pyrex[input=py, output=py, caption={Unordered collections with only unique values: sets}]{chapter03/1darray6}


%Beyond the class (which is a powerful function because you can create new classes your self), you can also get the R internal type of the object (storage mode), using the typeof() function:
%\begin{exampler}
%typeof(scores)
%\end{exampler}


\paragraph{Factors}

Finally, a data structure similar to a vector is the \fn{factor}.
R users are very likely tp encounter factors, which can be very useful when
working with categorical data. Factors
store the values of a vector with corresponding labels.%, which in
turn will produce levels.
If you create a factor, it will
automatically read the labels from the values of the vector, but you
may manually change those levels. Let's have a look at
\refex{1darray6}.  The first line will create again a vector of scores
of ten students. Then we automatically convert the vector into a
factor (reading the very same values as labels) and finally we create
the labels (``fail" or ``pass") for each of the possible grades.  The
factor-type object factor\_scores\_2 will be probably more useful to
deal with a bigger amount of students. While we have only two levels
(which can be identified with the function \fn{nlevels}), we can have many
values to connect with those labels.

\pyrex[input=r, output=none, caption=Factors can also store labels]{chapter03/1darray6}

Python does not natively support factors. The \pkg{pandas} library,
which we will use later throught this book, introduces a datatype called
\fn{Categorical} that serves the same purpose, but it is much less
used than factors are in R.



\subsection{Dictionaries}
Almost all data structures in R have a similar equivalent in Python
and vice versa. There is one exception, though: \emph{dictionaries}. A
dictionary, also known as associative array or hash table, is a very
popular data structure in Python, but does not exist in R.

Dictionaries contain unordered and mutable collections of objects that
contain certain information in another object. Python generates this
data type in form of |{key : value}| pairs in order
to map any object by its key and not by its relative position in the
collection. Unlike in a list, in which you index with an integer denoting
the position in a list, you can index a dictionary using the key.
For example, in \refex{dict}, we want to get the values of the object 'positive' in the
dictionary \emph{sentiments} and of the object 'A' in the dictionary
\emph{grades}.You will
find dictionaries very useful in your journey as a computational
scientist or practitioner, since they are flexible ways to store and
retrieve structured information. We can create them using the curly
brackets {} and including each key-value pair as an element of the
collection (\refex{dict}).

\pyrex[input=py, output=py, caption=Dictionaries store key-value pairs]{chapter03/dict}

A good analogy for a dictionary is a telephone book (imagine a paper
one, but it actually often holds true for digital phone books as
well): The names are the keys, and the associated phone numbers the
values. If you know someone's name (the key), it is \emph{very easy}
to look up the corresponding values: even in a phone book of thousands
of pages, it takes you maybe 10 or 20 seconds to look up the name
(key). But if you know someones phone number (the value) instead and
want to look up the name, that's very inefficient: you need to read
the whole phone book until you find the number.

Just as the elements of a list can be of \emph{any} type, and you can
have lists of lists, you can also nest dictionaries to get dicts of
dicts. Think of our phone book example: rather than storing just a
phone number as value, we could store another dict with the keys
'office phone', 'mobile phone', etc. This is very often done, and you
will come across many examples dealing with such data structures.
You have one restriction, though: the keys in a dictionary (as opposed
to the values) are not allowed to be mutable. After all, imagine that
you could use a list as a key in a dictionary, and if at the same time,
some other pointer to that very same list could just change it, this
would lead to a quite confusing situation.




\subsection{From 1D to 2D (and higher): matrices and n-dimensional arrays}

Matrices are two-dimensional rectangular data sets that include values
in rows and columns. This is the kind of data you will have to deal
with in many analyses shown in this book, such as those related to
machine learning. Often, we can generalize to higher dimensions.

\pyrex[caption=Working with two- or n-dimensional arrays, output=both]{chapter03/2darray}

In Python, the easiest representation is to simply construct a list of
lists. This is, in fact, often done, but has the disadvantage that
there are no easy ways to get, for instance, the dimensions (the
shape) of the table, or to print it in a neat(-er) format. To get all
that, one can transform the list of list into an |array|, a
datastructure provided by the package \pkg{numpy}.

To create a matrix in R, you have to use the function \fn{matrix} and
create a vector of values with the indication of how many rows and
columns will be on it. We also have to tell R if the order of the
values is determined by the row or not. In \refex{2darray}, we create
two matrices in which we vary the |byrow| argument to be TRUE and
FALSE, respectively, to illustrate how it changes the values of the
matrix, even when the shape (2x3) remains identical. As you may
imagine, we can operate with matrices, such as adding up two of them.

A powerful data type are the arrays (very much like the \pkg{numpy}
arrays described above), which might be similar to matrices but
without the restriction of the two-dimensional rectangular space. This
means that you create your own dimensions, indicating (in order) the
number of rows, columns and matrices of the array. Your will need
vectors as inputs and dimensions as parameters. For example,
three-dimensional arrays are fundamental when writing pixel values and
coding images. 


\subsection{Making life easier: dataframes}

Dataframes are friendly data structures that look very much like
what you find in SPSS, Stata, or Excel. They will help you in a wide
range of statistical analysis (though in more advanced exercises such
in machine learning you will not be able to use them any more!).  A
data frame is a tabular data object that includes rows (usually the
instances or cases) and columns (the variables). In a three-column data frame,
the first variable can be \emph{numeric}, the second \emph{character}
and the third \emph{logical}, but the important thing is that each
variable is a vector and that all these vectors must be of the same
length. We create data frames from scratch using the data.frame()
function.  Letâ€™s generate a simple data frame of three instances (each
case is an author of this book) and three variables of the types
numeric (\emph{age}), character (\emph{country} where he obtained his
master degree) and logic (\emph{living abroad}, wether he currently
lives out of his born country) (\refex{dataframe1}).
Notice that you have the label of the variables at the top of each column and that it creates an automatic numbering for indexing the rows.  

\pyrex[caption=Creating a simple dataframe,output=py]{chapter03/dataframe1}
