\newcommand{\fnarrow}{\footnote{In both R and Python, the equals
  sign (\texttt{=}) can be used to assign values. In R, however, the
  traditional way of doing this is using an arrow (\texttt{\textless-}). In
  this book we will use the equals sign for assignment in both
  languages, but remember that for R, \texttt{x = 10} and
  \texttt{x \textless-10} are essentially the same.}}


\section{About objects and data types}
\label{sec:datatypes}

Now that you have all the necessary software in you own computer we
can move on to the very basics of data analysis in R and
Python\footnote{If you have not installed the require software yet and
  still want to follow this chapter, you may use available online
  platforms for RStudio (https://rstudio.cloud/) and Python
  (https://www.python.org/shell/).}.  In both languages, you write a
\emph{script} or \emph{program} containing the commands for the
computer to do data processing or other tasks.  But before we get to
some real programming and exciting data analyses, we need to understand
how data can be represented and stored.

No matter whether you use R or Python, both store your data in memory as \emph{objects}.
Each of these objects has a name, and you create them by
assigning a value to a name. For example, the command \texttt{x = 10}
creates a new object\fnarrow, named \texttt{x}, and stores the value 10
in it.  This object is now stored in memory and can be used in later
commands.

\note{A small note on terminology: In programming, a distinction is
  often made between an object (such as the number 10) and the
  variable in which it is store (such as \texttt{x}). The latter is also called a ``pointer''.
  However, this distinction is not very relevant for most of our
  purposes. Morever, in statistics, the word variable often refers to a
  column of data, rather than to the name of, for instance, the object
  containing the whole data frame (or table).  For that
  reason, we will use the word \emph{object} to refer to both the
  actual object or value and its name.}

Objects can be simple values such as the number 10, but they can also
be pieces of text, whole data frames (tables), or analysis results.
We call this distinction the \emph{type} or \emph{class} of an
object.  You can inspect the type of an object with the \code{type}
(Python) or \code{class} (R) function, as shown in example \refex{objecttype}. 

Let' create an object that we call |a| (an arbitray name, you can use
whatever you want) an assign a value, 100, to it (see \refex{var1}).

\pyrex[output=both,caption=Determining the type of an object]{chapter03/var1}

As you can see, R reports the type of the number as `numeric', while Python reports it
as `int', short for integer or whole number.  Although they use
different names, both languages offer very similar data types.
\reftab{types} provides an overview of the data types we will
encounter most frequently in this book.  As you can see,
both Python and R have very similar types for simple data such as
numbers, text, and truth values.

\newcommand{\fndouble}{In R, double and numeric can generally be used
  interchangably (there is a subtle difference, but that is not
  relevant here).}

\begin{table}
  \caption{\label{tab:types}Most used data types in python and R}{
  \begin{tabularx}{\textwidth}{lllll}
    \toprule
    \multicolumn{2}{c}{Python} & \multicolumn{2}{c}{R}& Description \\
    \cmidrule(lr){1-2}    \cmidrule(lr){3-4}\\
    Name & Example & Name & Example \\
    \midrule
    int   & \verb+1+             & integer   & \verb+1L+             & whole numbers \\
    float & \verb+1.3+           & numeric   & \verb+1.3+           & numbers with decimals \\
    str   & \verb+"Spam", 'ham'+ & character & \verb+"Spam", 'ham'+ & textual data  \\ 
    bool  & \verb+True, False+   & logical   & \verb+TRUE, FALSE+   & the truth values \\
    \bottomrule
  \end{tabularx}}{}
\end{table}
    


Let's have a closer look at the code in \refex{var1}.

The first line is mandatory to create the object \emph{a} and store
its value 100; and the second is illustrative and will give you the
class of the created object, in this case ``numeric''. Notice that we
are using two native functions of R, \fn{print} and \fn{class}, and
including |a| as an argument of \fn{class}, and the very same
\fn{class(a)} as an argument of \fn{print}. The only difference
between R and Python, here, is that the relevant Python function is
called \fn{type} instead of \fn{class}.

%This is the way we work in object-orientated programming and if you
%compare to other languages you will realize that is a very simple
%syntax indeed.
Once created, you can now perform multiple operations
with |a| and other values or new variables. For example, you
could transform |a| by multiplying |a| by 2, create a new
variable |b| of value 50 and then create another new object
|c| with the result of |a + b| (\refex{var2}).

\pyrex[output=both,caption=Some simple operations]{chapter03/var2}




\subsection{Storing single values: integers, floating-point numbers, booleans}

When working with numbers, we distinguish between integers (whole
numbers) and floating point numbers (numbers with a decimal point,
called `numeric' in R). Both Python and R automatically determine the
correct data type when creating an object, but differ in their default
behavior when storing a number that can be represented as an int: R
will store it as float anyway and you need to force it to do
otherwise, for Python it is the other way round
(\refex{var3}). We can also convert between types later on,
even though converting a float to an int might not be a too good idea,
as you truncate your data.

So why not just always use a float? First,
floating point operations usually take more time than integer operations.
Second, because floating point numbers are stored as a combination of
a coefficient and an exponent (to the base of 2), many integers (or,
in fact, many decimal fractions) can only approximately be stored
as a floating point number. Except for specific domains (such
as finance), these inaccuracies are often not of much practical importance.
But it explains why calculating |6*6/10| in Python returns 3.6, while
|6*0.6| or |6*(6/10)| returns 3.5999999999999996. Therefore, if
a value can logically only be a whole number (anything that is
countable, in fact), it makes sense to restrict it to an integer.

We also have a data type that is even more restricted and can take
only two values: true or false. It is called `logical' (R) or `bool'
(Python).  Just notice that True or False values are case sensitive
and while in R you must capitalize the whole value (|TRUE|, |FALSE|), in
Python we only capitalize the first letter: |True|, |False|.  As you can
see in \refex{var3}, such an object behaves exactly as an integer that
is only allowed to be 0 or 1, and it can easily be converted to an
integer.

\pyrex[caption={Floating point numbers, integers, and boolean values}]{chapter03/var3}




\subsection{Storing text}

As a computational analyst of communication you will usually work with
text objects or strings of characters. Commonly known as simply ``strings'',
such text objects are also referred to as ``character vector objects'' in R.
You can create them just by adding single or double quotes around the value of the variable (keep in mind to begin and finish the string either with single or with double quotes, and not to mix their use). Every time you want to analyse a social-media message, or any other text, you will be dealing with such strings. 

\pyrex[caption=Strings and bytes]{chapter03/var4}

It is not too difficult to imagine how a computer internally
handles \emph{integers}: After all, even though the number may be displayed
as a decimal number to us, it can be trivially converted and stored
as a binary number (effectively, a series of zeros and ones)
--- we do not have to care about that, as there
is only one way of doing so. But when we think about text, it is not
immediately obvious how a string should be stored as a sequence of
zeros and ones.
Indeed, here are several ways of how textual characters can be stored as
bytes, and it is important to be aware of this.
Although you probably will not encounter this too often, sometimes
we even have to process raw bytes. Quite confusingly, bytes are also often
displayed as letters, but they are different: To begin with, a byte
only has $2^8=256$ possible values, while there are more than one
million possible characters that can form one character in a (Unicode)
string. Sometimes, we  may need a low-level approach in which we care about the exact
bytes underlying a string. You can read more about this in
\refsec{encodings}.  \refex{var4} shows how to create strings and raw
(byte) strings. In your daily work, you will almost never want to
create raw byte strings, but you may encounter them either because
they have been used historically (in Python 2, strings by default
were considered raw byte strings, and you needed to specify if
you wanted to do otherwise), or because data that you retrieve from
online sources may come as raw bytes (see \refchap{scraping}).

As you see in \refex{var4}, a string is denoted by quotation
marks. You can use either double or single quotation marks, but you
need to use the same mark to begin and end the string. This can be
useful if you want to use quotationmarks within a string, then you can
use the other type to denote the beginning and end of the string.

\note{Since Python 3.6, there is a new type of string, the f-string. These are strings that are prefixed with the letter \texttt{f} and are \emph{formatted} strings. This means that these strings will automatically insert a value were curly brackets indicate you wish to do so. This means that you can write: \texttt{print(f'The value of i is \{i\}'} to print ``The value of i is 5'', given that i is 5. In a similar fashion, you can prevent Python from interpreting special characters by prefixing the string with the letter \texttt{r}, which can be useful when writing regular expressions (\refsec{regular}). In R, the \pkg{glue} package allows you to use a f-string-like syntax as well.}


\subsection{Combining multiple values: lists, vectors, and friends}

Until now, we have focused on the basic, inital datatypes or ``vector
objects'', as they are called in R.  Often, however, we want to group
multiple of these objects. For example, we do not want to manually
create thousands of objects called tweet0001, tweet0002, \ldots
tweet9999 -- we'd rather have one list called tweets that contains all
of them. You will encounter several names for such combined data
structures: lists, vectors, one-dimensional arrays, series, and maybe
even more. 

\begin{table}[ht]
\label{tab:vector_objects}
\caption{Classes of vector objects in R\label{table:nonlin}}{%
\centering
\begin{tabular}{c c c p{2cm}}
\hline\hline
Data type & Example & Code \\ [0.5ex]
\hline
Numeric&1, 2.5, 100, 2500.38& a = 100 \\
Integer&20L, 100L&d = 20L \\
%Complex& 100+50x, 8*3i &e = 100+50x \\
Character&   \parbox[t]{4cm}{\centering 'a', "I am happy learning R!!!", "200", 'R', "FALSE"} & tweet  = "I am happy learning R!!!" \\
Raw& \parbox[t]{4cm}{\centering "Any text" stored as:  41 6e 79 20 74 65 78 74} & raw\_string  = charToRaw("Any text") \\
Logical& TRUE, FALSE & logical\_operator  = TRUE  \\ [1ex]
\hline
\end{tabular}}{}
\end{table}


Table~\ref{tab:vector_objects} summarizes vector objects available in
R. By bringing together a set of same-class vector objects we can
create a vector. A vector is a basic structure of R and holds
different elements of the same type (numeric, integer, complex,
character, logical, raw) in a one-dimensional array. You will use
vectors very often to run computation and we can easily create them
using the \fn{c} function. For example, we can create a numeric vector
with the scores of a class of 10 students or a character vector of
three countries (\refex{1darray1}).

\pyrex[caption=Vectors in R, output=r, input=r]{chapter03/1darray1}

As you see, the data types will correspond to only one class, either
numeric or character, since vectors contain only one class. If we
create the vector with two different data types, R will recognize one
class forcing some elements to be transformed into the dominant
class. For example, if you re-build the vector of scores (a new set of
values will be loaded into the workspace) with a new student who has
been graded with the letter \emph{b} instead of a number, your vector
will become a character vector. If you print it, you will see that the
values are now displayed surrounded by |"|.

%Beyond the class (which is a powerful function because you can create new classes your self), you can also get the R internal type of the object (storage mode), using the typeof() function:
%\begin{exampler}
%typeof(scores)
%\end{exampler}

Having a vector means that you can operate with it in many ways. One of the
basic operations is \emph{indexing}, which is a technique that you will use with
other data types (list, arrays, matrices, data frames) and in other
languages such as Python.  Indexing helps you to locate any given
element or group of elements within a vector using its or their
positions. In R all positions begin in the number 1 (you will see that
in Python and other languages they will begin on 0) and you can index
using the square brackets [] over the vector (\refex{1darray2}).

\pyrex[input=r, output=r, caption=Slicing vectors and converting data types]{chapter03/1darray2}

In the first case, we asked for the score of the 11th student ("b");
in the second we asked for the 1st and 10th position ("8" "5"); and
finally for all the elements between the 1st and 10th position ("8"
"8" "7" "6" "9" "4" "9" "2" "8" "5"). We can directly indicate a range
by using a |:|. After the colon, we provide the index of
the last element (in R), while Python stops just \emph{before} the index
\footnote{This is related to the
reason why Python starts counting with zero. If you are intetested
in this, have a look at \url{https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html}}
If we want to pass multiple single index values instead of a range,
we need to create a vector of these indices by using |c()| (\refex{1darray2}). 

As the vector |scores2| was forced to be a string, all the elements --
even those that could be represented as numeric -- are now
characters. Indexing is very useful to access elements and also to
create new objects from a part of another one. Imagine you want to
create a new numeric vector by \emph{slicing} the vector scores with
just the numeric values and change its class using the function
as.numeric (\refex{1darray2}).

And voilà, we have a new object called scores3 with the original
values of the vector scores and of the class numeric.
% \emph{double} (double precision floating point numbers, which is equivalent to the class numeric).

\pyrex[input=r, output=r, caption=Some more vector operations]{chapter03/1darray3}

We can do many other things like adding a value to an existing vector
or creating a vector from scratch by using a
function. \refex{1darray3} illustrates how to include the new numeric
score of 7 (imagine we translate the grade \emph{b} to the number 7)
to our vector by two procedures, or how to remove an element from your
vector. For example, for dropping the 11th student's score recently included you
just index negatively the value of the vector: |[-11]|.

Rather than just typing over a lot of values by hand, we often might
wish to create a vector from an operator or a function, without typing
each value. Using the operator ':', we can create numeric vectors with
a range of numbers, from 1 to 20 or from -5 to 5 (\refex{1darray3}).
You can also use a function to create more complex vectors. For
example the function \fn{seq} will help you to generate regular sequences
by providing the number of points of an interval.  Imagine you want to
create a numeric vector than begins in point 0 and finishes in point
1, including all possible values that separate those two points by a
step of 0.2. Let's create that vector and check the amount of created
elements by using the function \fn{length} (\refex{1darray3}).

A similar R object is the factor, which might be very useful when
working with categorical data. When dealing with factors, you can
store the values of a vector with their corresponding labels, which in
turn will produce levels. If you create a factor, it will
automatically read the labels from the values of the vector, but you
may manually change those levels. Let's have a look at
\refex{1darray6}.  The first line will create again a vector of scores
of ten students. Then we automatically convert the vector into a
factor (reading the very same values as labels) and finally we create
the labels (``fail" or ``pass") for each of the possible grades.  The
factor-type object factor\_scores\_2 will be probably more useful to
deal with a bigger amount of students. While we have only two levels
(which can be identified with the function \fn{nlevels}), we can have many
values to connect with those labels.

\pyrex[input=r, output=none, caption=Factors can also store labels]{chapter03/1darray6}



While vectors are probably the most common one-dimensional data
structure in R, there are other ones. In particular, we have
\emph{lists}. A list is similar to vectors but may contain different
type of elements, functions and even other lists. We create lists in a
similar way to vectors, except that we have to add the word |list|
before declaring the values. Let's build a list with four different
kind of elements, a numeric object, a character object, a square root
function (\fn{sqrt}) and a numeric vector (\refex{1darray4}). In fact, you
can use any of the elements in the list through indexing -- even the
function \fn{sqrt} that you stored in there to get the square root of
16!

\pyrex[input=r, output=r, caption=Lists can store multiple data types]{chapter03/1darray4}



In Python, such lists are, in fact, the most common type for creating
a one-dimensional collection of basic data types. 

Python lists are mutable sequences of different types of elements. In other
words, they are ordered collections of objects with no fixed size. We
build this Python object using square brackets [], instead of
parentheses (), as we did in R. Pay attention to this detail because
in Python we will create tuples if you use the parentheses. Tuples are
similar to lists, except that they are immutable (which means that
they are constant or unchangeable and you can not freely change their
values, just as numbers or strings).  We can now create our first list
and tuple, and get their sizes with the native function len
(\refex{1darray5}). We have created two sequences of six objects
(three integers and three strings) that represent common numeric and
categorical values for sentiment analysis. The first sequence is a
list and the second a tuple. We can get any value of the list or tuple
by indexing its position, just keep in mind that indexing in Python
begins in 0 and not in 1 like in R. 

\pyrex[input=py, output=py, caption=Lists and tuples in Python]{chapter03/1darray5}

Imagine now that you decide that the value `neutral' should be
substituted by the value `informative' in the created sequences. You
can update them by just assigning a new value to an item that is
identified by its index.  The list will be correctly updated, but the
code you run to change the tuple will give you an error (with some
message such as: "'tuple' object does not support item
assignment"). Thus, tuples are immutable and are worth for certain
types of operations because they give stability to a particular
computation. Notice that we can include any object into lists or
tuples.


\note{While most of the time, you will not care about mutable or
  immutable objects, the fact that lists (and, later, data frames) are
  mutable can be really crucial if you. \refex{mutable} illustrates
  what happens if you create a new object referring to a mutable
  object, which -- in contrast to what you may think -- does not
  create a copy of the object itself. Rather, we now get two names for
  the same object.}

\pyrex[input=py, output=py, caption={The (for many unexpected) behavior of mutable objects}]{chapter03/mutable}



We also have another Python object called sets. A set is a mutable
collection of \emph{unique} elements (you cannot repeat a value) with
no order. As it is not properly ordered, you cannot run any indexing
or slicing operation on it. The immutable version of sets are called
frozensets.

\pyrex[input=py, output=py, caption={Unordered collections with only unique values: sets}]{chapter03/1darray6}


While lists give you a lot of flexibility -- e.g., they happily accept
entries of very different types --, you sometimes may want a stricter
structure like R's vector. This may be especially interesting for
high-performance calculations, and therefore, such a structure is
avalable from the \pkg{numpy} (\emph{num}bers in \emph{py}thon)
package: the numpy array (\refex{1darray7}).

\pyrex[input=py, output=py, caption={Numpy arrays behave more like R vectors. However, you have to import (and potentially install) an additional package, \pkg{numpy}, for this (see \refsec{installing})}]{chapter03/1darray7}



\subsection{Dictionaries}
Almost all data structures in R have a similar equivalent in Python
and vice versa. There is one exception, though: \emph{dictionaries}. A
dictionary, also known as associative array or hash table, is a very
popular data structure in Python, but does not exist in R.

Dictionaries contain unordered and mutable collections of objects that
contain certain information in another object. Python generates this
data type in form of |{key : value}| pairs in order
to map any object by its key and not by its relative position in the
collection. Unlike in a list, in which you index with an integer denoting
the position in a list, you can index a dictionary using the key.
For example, in \refex{dict}, we want to get the values of the object 'positive' in the
dictionary \emph{sentiments} and of the object 'A' in the dictionary
\emph{grades}.You will
find dictionaries very useful in your journey as a computational
scientist or practitioner, since they are flexible ways to store and
retrieve structured information. We can create them using the curly
brackets {} and including each key-value pair as an element of the
collection (\refex{dict}).

\pyrex[input=py, output=py, caption=Dictionaries store key-value pairs]{chapter03/dict}

A good analogy for a dictionary is a telephone book (imagine a paper
one, but it actually often holds true for digital phone books as
well): The names are the keys, and the associated phone numbers the
values. If you know someone's name (the key), it is \emph{very easy}
to look up the corresponding values: even in a phone book of thousands
of pages, it takes you maybe 10 or 20 seconds to look up the name
(key). But if you know someones phone number (the value) instead and
want to look up the name, that's very inefficient: you need to read
the whole phone book until you find the number.

Just as the elements of a list can be of \emph{any} type, and you can
have lists of lists, you can also nest dictionaries to get dicts of
dicts. Think of our phone book example: rather than storing just a
phone number as value, we could store another dict with the keys
'office phone', 'mobile phone', etc. This is very often done, and you
will come across many examples dealing with such data structures.
You have one restriction, though: the keys in a dictionary (as opposed
to the values) are not allowed to be mutable. After all, imagine that
you could use a list as a key in a dictionary, and if at the same time,
some other pointer to that very same list could just change it, this
would lead to a quite confusing situation.




\subsection{From 1D to 2D (and higher): matrices and n-dimensional arrays}

Matrices are two-dimensional rectangular data sets that include values
in rows and columns. This is the kind of data you will have to deal
with in many analyses shown in this book, such as those related to
machine learning. Often, we can generalize to higher dimensions.

\pyrex[caption=Working with two- or n-dimensional arrays, output=both]{chapter03/2darray}

In Python, the easiest representation is to simply construct a list of
lists. This is, in fact, often done, but has the disadvantage that
there are no easy ways to get, for instance, the dimensions (the
shape) of the table, or to print it in a neat(-er) format. To get all
that, one can transform the list of list into an |array|, a
datastructure provided by the package \pkg{numpy}.

To create a matrix in R, you have to use the function \fn{matrix} and
create a vector of values with the indication of how many rows and
columns will be on it. We also have to tell R if the order of the
values is determined by the row or not. In \refex{2darray}, we create
two matrices in which we vary the |byrow| argument to be TRUE and
FALSE, respectively, to illustrate how it changes the values of the
matrix, even when the shape (2x3) remains identical. As you may
imagine, we can operate with matrices, such as adding up two of them.

A powerful data type are the arrays (very much like the \pkg{numpy}
arrays described above), which might be similar to matrices but
without the restriction of the two-dimensional rectangular space. This
means that you create your own dimensions, indicating (in order) the
number of rows, columns and matrices of the array. Your will need
vectors as inputs and dimensions as parameters. For example,
three-dimensional arrays are fundamental when writing pixel values and
coding images. 


\subsection{Making life easier: dataframes}

Dataframes are friendly data structures that look very much like
what you find in SPSS, Stata, or Excel. They will help you in a wide
range of statistical analysis (though in more advanced exercises such
in machine learning you will not be able to use them any more!).  A
data frame is a tabular data object that includes rows (usually the
instances or cases) and columns (the variables). In a three-column data frame,
the first variable can be \emph{numeric}, the second \emph{character}
and the third \emph{logical}, but the important thing is that each
variable is a vector and that all these vectors must be of the same
length. We create data frames from scratch using the data.frame()
function.  Let’s generate a simple data frame of three instances (each
case is an author of this book) and three variables of the types
numeric (\emph{age}), character (\emph{country} where he obtained his
master degree) and logic (\emph{living abroad}, wether he currently
lives out of his born country) (\refex{dataframe1}).

\pyrex[caption=Creating a simple dataframe,output=py]{chapter03/dataframe1}

Notice that you have the label of the variables at the top of each column and that it creates an automatic numbering for indexing the rows.  


%As an object-orientated language programming, Python allows us to create objects, variables or functions, and load them into its workspace. The fundamentals are the same of R, so if you correctly understood the last explanations you will find very easy to do the same in Python. However, keep in mind that you will probably have to develop more skills to master Python since this programming language is not constrained to statistics and is flexible for many more computational tasks, both at small and large scale. This means that its syntax might become more complex than R, even when you will not need to know all of it to run most of computational analysis of communication.  For a deeper and understandable reading of Python programming we recommend the book by M. Lutz\cite{lutz2013learning}. Nonetheless, in the next paragraphs we will introduce you to the variables and data types in Python, so you can easy follow the book and the proposed exercises.  

%A good way to start is to understand the built-in object types in Python and how to operate with them. Similarly to R we have numeric, integer, complex, character and logical, which we will now call float, integer, complex, string and boolean, respectively. Objects will also include lists, tuples, sets, dictionaries, functions and classes. If you are missing vectors, arrays or matrices as objects, do not worry, even when they are not built-in objects in Python, we can create them using specialized libraries such as Numpy (see chapter [DATA STRUCTURES]). Now you can open your Python console and we can create our first objects and load them into our workspace. First, let’s create a couple of objects \emph{x} and \emph{yy} containing only numbers as values, and third object \emph{z} that contains the result of an arithmetic operation between those two:





