\newcommand{\fnarrow}{\footnote{In both R and Python, the equals
  sign (\texttt{=}) can be used to assign values. In R, however, the
  traditional way of doing this is using an arrow (\texttt{\textless-}). In
  this book we will use the equals sign for assignment in both
  languages, but remember that for R, \texttt{x = 10} and
  \texttt{x \textless-10} are essentially the same.}}


\section{About objects and data types}
\label{sec:datatypes}

Now that you have all the necessary software in you own computer we
can move on to the very basics of data analysis in R and
Python\footnote{If you have not installed the require software yet and
  still want to follow this chapter, you may use available online
  platforms for RStudio (https://rstudio.cloud/) and Python
  (https://www.python.org/shell/).}.  In both languages, you write a
\emph{script} or \emph{program} containing the commands for the
computer to do data processing or other tasks.  Before we move on to
data processing, it is important to take a quick look at how data is
actually stored in the computer, and the basics of processing
commands.

All data is stored in the computer as \emph{objects}, and each object
that is stored in memory also has a name.  You create these objects by
assigning a value to a name. For example, the command \texttt{x = 10}
creates a new object\fnarrow, named \texttt{x}, and stores the value 10
in it.  This object is now stored in memory and can be used in later
commands.

\note{A small note on terminology: In programming, a distinction is
  often made between an object (such as the number 10) and the
  variable in which (a pointer to) it is store (such as \texttt{x}).
  However, this distinction is not very relevant for our
  usage. Morever, in statistics the word variable often refers to a
  column of data, rather than to the name of the data frame.  For that
  reason, we will use the word \emph{object} to refer to both the
  actual object or value and its name, and will avoid the word
  variable. }

Objects can be simple values such as the number 10, but they can also
be pieces of text, whole data frames, or analysis results.  The
computer keeps track of the \emph{type}, or \emph{class}, of each
object.  You can inspect the type of an object with the \code{type}
(python) or \code{class} function, as shown in example X.  We will
explain the concept of a function later, but you can essentially see
it as asking a specific question or issuing a command, in this case
the question of what the type of the given object is.

Let' create an object that we call |a| (an arbitray name, you can use
whatever you want) an assign a value, 100, to it (see \refex{var1}).

\pyrex[output=both,caption=Determining the type of an object]{chapter03/var1}

As you can see, R calls the number `numeric', while python reports it
as being `int', short for integer or whole number.  Although they use
different names, both languages offer very similar data types.
\reftab{tab:types} provides an overview of the data types we will
encounter most frequently in this book.  As you can see in the table,
both python and R have very similar types for simple data such as
numbers, text, and truth values.

\newcommand{\fndouble}{In R, double and numeric can generally be used
  interchangably (there is a subtle difference, but that is not
  relevant here).}

\begin{table}
  \begin{tabularx}{\textwidth}{lllll}
    \toprule
    \multicolumn{2}{c}{Python} & \multicolumn{2}{c}{R}& Description \\
    \cmidrule(lr){1-2}    \cmidrule(lr){3-4}\\
    Name & Example & Name & Example \\
    \midrule
    int   & \verb+1+             & integer   & \verb+1L+             & whole numbers \\
    float & \verb+1.3+           & numeric   & \verb+1.3+           & Numbers with decimal \\
    str   & \verb+"Spam", 'ham'+ & character & \verb+"Spam", 'ham'+ & Textual data  \\ 
    bool  & \verb+True, False+   & logical   & \verb+TRUE, FALSE+   & The truth values \\
    \bottomrule
  \end{tabularx}
  \caption{\label{tab:types}Most used data types in python and R}
\end{table}
    


Let's have a closer look at the code in \refex{var1}.

The first line is mandatory to create the object \emph{a} and store
its value 100; and the second is illustrative and will give you the
class of the created object, in this case "numeric". Notice that we
are using two native functions of R, \fn{print} and \fn{class}, and
including |a| as an argument of \fn{class}, and the very same
\fn{class(a)} as an argument of \fn{print}. The only difference
between R and Python, here, is that the relevant Python function is
called \fn{type} instead of \fn{class}.

This is the way we work in object-orientated programming and if you
compare to other languages you will realize that is a very simple
syntax indeed. Once created, you can now perform multiple operations
with |a| and other values or new variables. For example, you
could transform |a| by multiplying |a| by 2, create a new
variable |b| of value 50 and then create another new object
|c| with the result of |a + b| (\refex{var2}).

\pyrex[output=both,caption=Some simple operations]{chapter03/var2}




\subsection{Storing single values: integers, floating-point numbers, booleans}

When working with numbers, we distinguish betwee integers (whole
numbers) and floating point numbers (numbers with a decimal point,
called `numeric' in R). Both Python and R automatically determine the
correct datatype when creating an object, but differ in their default
behavior when storing a number that can be represented as an int: R
will store it as float anyway and you need to force it to do
otherwise, for Python it is the other way round
(Example~\refex{var3}). We can also convert between types later on,
even though converting a float to an int might not be a too good idea,
as you truncate your data.

We also have a data type that is even more restricted and can take
only two values: true or false. It is called `logical' (R) or `bool'
(Python).  Just notice that True or False values are case sensitive
and while in R you must capitalize the whole value (TRUE, FALSE), in
Python we only capitalize the first letter: True, False.  As you can
see in \refex{var3}, such an object behaves exactly as an integer that
is only allowed to be 0 or 1, and it can easily be converted to an
integer.

\pyrex[caption=Floating point numbers\, integers\, and boolean values]{chapter03/var3}




\subsection{Storing text}

As a computational analyst of communication you will usually work with text objects or string of characters, which are called character vector objects in R, and you can create them just by adding single or double quotes to the value of the variable. Just think of a tweet or a Facebook post that you want to load into your workspace for natural language processing analysis.

\pyrex[caption=Strings and bytes]{chapter03/var4}

As we will discuss in Section~\ref{sec:encodings}, there are several ways of how textual characters can be stored as bytes. You probably will not encounter this too often, but sometimes we may need a low-level approach in which we care about the exact bytes underlying a string. \refex{var4} shows how to create string and raw (byte) strings.

As you see in \refex{var4}, a string is denoted by quotation marks. You can use either double or single quotation marks, but you need to use the same mark to begin and end the string. This can be useful if you want to use quotationmarks within a string, then you can use the other type to denote the beginning and end of the string.




\subsection{Combining multiple values: lists, vectors, and friends}

Until now, we have focused on the basic, inital datatypes or ``vector
objects'', as they are called in R.  Often, however, we want to group
multiple of these objects. For example, we do not want to manually
create thousands of objects called tweet0001, tweet0002, \ldots
tweet9999 -- we'd rather have one list called tweets that contains all
of them. You will encounter several names for such combined data
structures: lists, vectors, one-dimensional arrays, series, and maybe
even more. Because the typical usage differs a bit between R and
Python, we will discuss them one by one, starting with R.


\begin{table}[ht]
\label{tab:vector_objects}
\caption{Classes of vector objects in R}
\centering
\begin{tabular}{c c c p{2cm}}
\hline\hline
Data type & Example & Code \\ [0.5ex]
\hline
Numeric&1, 2.5, 100, 2500.38& a = 100 \\
Integer&20L, 100L&d = 20L \\
Complex& 100+50x, 8*3i &e = 100+50x \\
Character&   \parbox[t]{4cm}{\centering 'a', "I am happy learning R!!!", "200", 'R', "FALSE"} & tweet  = "I am happy learning R!!!" \\
Raw& \parbox[t]{4cm}{\centering "Any text" stored as:  41 6e 79 20 74 65 78 74} & raw\_string  = charToRaw("Any text") \\
Logical& TRUE, FALSE & logical\_operator  = TRUE  \\ [1ex]
\hline
\end{tabular}
\label{table:nonlin}
\end{table}


Table~\ref{tab:vector_objects} summarizes vector objects available in
R. By bringing together a set of same-class vector objects we can
create a vector. A vector is a basic structure of R and holds
different elements of the same type (numeric, integer, complex,
character, logical, raw) in a one-dimensional array. You will use
vectors very often to run computation and we can easily create them
using the c() function. For example, we can create a numeric vector
with the scores of a class of 10 students or a character vector of
three countries (\refex{1darray1}).

\codex[caption=Vectors in R]{chapter03/1darray1.r}

As you see, the data types will correspond to only one class, either
numeric or character, since vectors contain only one class. If we
create the vector with two different data types, R will recognize one
class forcing some elements to be transformed into the dominant
class. For example, if you re-build the vector of scores (a new set of
values will be loaded into the workspace) with a new student who has
been graded with the letter \emph{b} instead of a number, your vector
will become a character vector. If you print it, you will see that the
values are now displayed surrounded by |"|.

%Beyond the class (which is a powerful function because you can create new classes your self), you can also get the R internal type of the object (storage mode), using the typeof() function:
%\begin{exampler}
%typeof(scores)
%\end{exampler}

Having a vector means that you can operate with it in many ways. The
basic is \emph{indexing}, which is a technique that you will use with
other data types (list, arrays, matrices, data frames) and in other
languages such as Python.  Indexing helps you to locate any given
element or group of elements within a vector using its or their
positions. In R all positions begin in the number 1 (you will see that
in Python and other languages they will begin on 0) and you can index
using the square brackets [] over the vector (\refex{1darray2}).

\codex[caption=Slicing vectors and converting data types]{chapter03/1darray2.r}

In the first case, we asked for the score of the 11th student ("b");
in the second we asked for the 1st and 10th position ("8" "5"); and
finally for all the elements between the 1st and 10th position ("8"
"8" "7" "6" "9" "4" "9" "2" "8" "5"). Note that while we can directly
indicate a range by using a |:|, but if we want to pass multiple
single index values, we need to create a vector of these indices by
using |c()| (\refex{1darray2}).

As the vector |scores2| was forced to be a string, all the elements --
even those that could be represented as numeric -- are now
characters. Indexing is very useful to access elements and also to
create new objects from a part of another one. Imagine you want to
create a new numeric vector by \emph{slicing} the vector scores with
just the numeric values and change its class using the function
as.numeric (\refex{1darray2}).

And voilà, we have a new object called scores3 with the original
values of the vector scores and of the class numeric.
% \emph{double} (double precision floating point numbers, which is equivalent to the class numeric).

\codex[caption=Some more vector operations]{chapter03/1darray3.r}

We can do many other things like adding a value to an existing vector
or creating a vector from scratch by using a
function. \refex{1darray3} illustrates how to include the new numeric
score of 7 (imagine we translate the grade \emph{b} to the number 7)
to our vector by two procedures, or how to remove an element from your
vector. For example, for dropping the 11th student's score recently included you
just index negatively the value of the vector: |[-11]|.

Rather than just typing over a lot of values by hand, we often might
wish to create a vector from an operator or a function, without typing
each value. Using the operator ':', we can create numeric vectors with
a range of numbers, from 1 to 20 or from -5 to 5 (\refex{1darray3}).
You can also use a function to create more complex vectors. For
example the function \fn{seq} will help you to generate regular sequences
by providing the number of points of an interval.  Imagine you want to
create a numeric vector than begins in point 0 and finishes in point
1, including all possible values that separate those two points by a
step of 0.2. Let's create that vector and check the amount of created
elements by using the function \fn{length} (\refex{1darray3}).

A similar R object is the factor, which might be very useful when
working with categorical data. When dealing with factors, you can
store the values of a vector with their corresponding labels, which in
turn will produce levels. If you create a factor, it will
automatically read the labels from the values of the vector, but you
may manually change those levels. Let's have a look at
\refex{1darray6}.  The first line will create again a vector of scores
of ten students. Then we automatically convert the vector into a
factor (reading the very same values as labels) and finally we create
the labels (``fail" or ``pass") for each of the possible grades.  The
factor-type object factor\_scores\_2 will be probably more useful to
deal with a bigger amount of students. While we have only two levels
(which can be identified with the function \fn{nlevels}), we can have many
values to connect with those labels.

\codex[caption=Factors can also store labels]{chapter03/1darray6.r}



While vectors are probably the most common one-dimensional data
structure in R, there are other ones. In particular, we have
\emph{lists}. A list is similar to vectors but may contain different
type of elements, functions and even other lists. We create lists in a
similar way to vectors, except that we have to add the word |list|
before declaring the values. Let's build a list with four different
kind of elements, a numeric object, a character object, a square root
function (sqrt) and a numeric vector (\refex{1darray4}). In fact, you
can use any of the elements in the list through indexing -- even the
function \fn{sqrt} that you stored in there to get the square root of
16!

\codex[caption=Lists can store multiple data types]{chapter03/1darray4.r}



In Python, such lists are, in fact, the most common type for creating
a one-dimensional collection of basic data types. 

Lists are mutable sequences of different types of elements. In other
words, they are ordered collections of objects with no fixed size. We
build this Python object using square brackets [], instead of
parentheses (), as we did in R. Pay attention to this detail because
in Python we will create tuples if you use the parentheses. Tuples are
similar to lists, except that they are immutable (which means that
they are constant or unchangeable and you can not freely change their
values, just as numbers or strings).  We can now create our first list
and tuple, and get their sizes with the native function len
(\refex{1darray5}). We have created two sequences of six objects
(three integers and three strings) that represent common numeric and
categorical values for sentiment analysis. The first sequence is a
list and the second a tuple. We can get any value of the list or tuple
by indexing its position, just keep in mind that indexing in Python
begins in 0 and not in 1 like in R.

\codex[caption=Lists and tuples in Python]{chapter03/1darray5.py}

Imagine now that you decide that the value `neutral' should be
substituted by the value `informative' in the created sequences. You
can update them by just assigning a new value to an item that is
identified by its index.  The list will be correctly updated, but the
code you run to change the tuple will give you an error (with some
message such as: "'tuple' object does not support item
assignment"). Thus, tuples are immutable and are worth for certain
types of operations because they give stability to a particular
computation. Notice that we can include any object into lists or
tuples.


\note{While most of the time, you will not care about mutable or
  immutable objects, the fact that lists (and, later, data frames) are
  mutable can be really crucial if you. \refex{mutable} illustrates
  what happens if you create a new object referring to a mutable
  object, which -- in contrast to what you may think -- does not
  create a copy of the object itself. Rather, we now get two names for
  the same object.}

\codex[caption=The \(for many unexpected\) behavior of mutable objects]{chapter03/mutable.py}


We also have another Python object called sets. A set is a mutable
collection of \emph{unique} elements (you cannot repeat a value) with
no order. As it is not properly ordered, you cannot run any indexing
or slicing operation on it. The immutable version of sets are called
frozensets.

\codex[caption=Unordered collections with only unique values\: sets]{chapter03/1darray6.py}


While lists give you a lot of flexibility -- e.g., they happily accept
entries of very different types --, you sometimes may want a stricter
structure like R's vector. This may be especially interesting for
high-performance calculations, and therefore, such a structure is
avalable from the \pkg{numpy} (\emph{nu}mbers in \emph{py}thon)
package: the numpy array (\refex{1darray7}).

\codex[caption=Numpy arrays behave more like R vectors]{chapter03/1darray7.py}
\codex{chapter03/1darray7.py.out}



\subsection{Dictionaries}
Almost all data structures in R have a similar equivalent in Python
and vice versa. There is one exception, though: \emph{dictionaries}. A
dictionary, also known as associative array or hash table, is a very
popular data structure in Python, but does not exist in R.

Dictionaries contain unordered and mutable collections of objects that
contain certain information in another object. Python generates this
data type in form of { 'key' : \textless value \textgreater} in order
to map any object by its key and not by its relative position in the
collection. This means that you will index using the key. You will
find dictionaries very useful in your journey as a computational
scientist or practitioner, since they are flexible ways to store and
retrieve structured information. We can create them using the curly
brackets {} and including each key-value pair as an element of the
collection (\refex{dict}).

\codex[caption=Dictionaries store key-value pairs]{chapter03/dict.py}
\codex{chapter03/dict.py.out}

As in other objects you can index its elements, by keep in mind that
you do it using the key and not the position in the sequences. For
example, we want to get the values of the object 'positive' in the
dictionary \emph{sentiments} and of the object 'A' in the dictionary
\emph{grades} (\refex{dict}).

A good analogy for a dictionary is a telephone book (imagine a paper
one, but it actually often holds true for digital phone books as
well): The names are the keys, and the associated phone numbers the
values. If you know someone's name (the key), it is \emph{very easy}
to look up the corresponding values: even in a phone book of thousands
of pages, it takes you maybe 10 or 20 seconds to look up the name
(key). But if you know someones phone number (the value) instead and
want to look up the name, that's very inefficient: you need to read
the whole phone book until you find the number.

Just as the elements of a list can be of \emph{any} type, and you can
have lists of lists, you can also nest dictionaries to get dicts of
dicts. Think of our phone book example: rather than storing just a
phone number as value, we could store another dict with the keys
'office phone', 'mobile phone', etc. This is very often done, and you
will come across many examples dealing with such data structures.




\subsection{From 1D to 2D (and higher): matrices and n-dimensional arrays}

Matrices are two-dimensional rectangular data sets that include values
in rows and columns. This is the kind of data you will have to deal
with in many analyses shown in this book, such as those related to
machine learning. Often, we can generalize to higher dimensions.

\pyrex[caption=Working with two- or n-dimensional arrays, output=both]{chapter03/2darray}

In Python, the easiest representation is to simply construct a list of
lists. This is, in fact, often done, but has the disadantage that
there are no easy ways to get, for instance, the dimensions (the
shape) of the table, or to print it in a neat(-er) format. To get all
that, one can transform the list of list into an |array|, a
datastructure provided by the package \pkg{numpy}.

To create a matrix in R, you have to use the function \fn{matrix} and
create a vector of values with the indication of how many rows and
columns will be on it. We also have to tell R if the order of the
values is determined by the row or not. In \refex{2darray}, we create
two matrices in which we vary the |byrow| argument to be TRUE and
FALSE, respectively, to illustrate how it changes the values of the
matrix, even when the shape (2x3) remains identical. As you may
imagine, we can operate with matrices, such as adding up two of them.

A powerful data type are the arrays (very much like the \pkg{numpy}
arrays described above), which might be similar to matrices but
without the restriction of the two-dimensional rectangular space. This
means that you create your own dimensions, indicating (in order) the
number of rows, columns and matrices of the array. Your will need
vectors as inputs and dimensions as parameters. For example,
three-dimensional arrays are fundamental when writing pixel values and
coding images. 


\subsection{Making life easier: dataframes}

Finally, we have the wonderful data frames. This is the friendly type
of data that you find in SPSS or Excel that will help you in a wide
range of statistical analysis (though in more advanced exercises such
in machine learning you will not be able to use them any more!).  A
data frame is a tabular data object that includes rows (usually the
instances) and columns (the variables). In a three-column data frame,
the first variable can be \emph{numeric}, the second \emph{character}
and the third \emph{logic}, but the important thing is that each
variable is a vector and that all these vectors must be of the same
length. We create data frames from scratch using the data.frame()
function.  Let’s generate a simple data frame of three instances (each
case is an author of this book) and three variables of the types
numeric (\emph{age}), character (\emph{country} where he obtained his
master degree) and logic (\emph{living abroad}, wether he currently
lives out of his born country) (\refex{dataframe1}).

\pyrex[caption=Creating a simple dataframe,output=py]{chapter03/dataframe1}

Notice that you have the label of the variables at the top of each column and that it creates an automatic numbering for indexing the rows.  


%As an object-orientated language programming, Python allows us to create objects, variables or functions, and load them into its workspace. The fundamentals are the same of R, so if you correctly understood the last explanations you will find very easy to do the same in Python. However, keep in mind that you will probably have to develop more skills to master Python since this programming language is not constrained to statistics and is flexible for many more computational tasks, both at small and large scale. This means that its syntax might become more complex than R, even when you will not need to know all of it to run most of computational analysis of communication.  For a deeper and understandable reading of Python programming we recommend the book by M. Lutz\cite{lutz2013learning}. Nonetheless, in the next paragraphs we will introduce you to the variables and data types in Python, so you can easy follow the book and the proposed exercises.  

%A good way to start is to understand the built-in object types in Python and how to operate with them. Similarly to R we have numeric, integer, complex, character and logical, which we will now call float, integer, complex, string and boolean, respectively. Objects will also include lists, tuples, sets, dictionaries, functions and classes. If you are missing vectors, arrays or matrices as objects, do not worry, even when they are not built-in objects in Python, we can create them using specialized libraries such as Numpy (see chapter [DATA STRUCTURES]). Now you can open your Python console and we can create our first objects and load them into our workspace. First, let’s create a couple of objects \emph{x} and \emph{yy} containing only numbers as values, and third object \emph{z} that contains the result of an arithmetic operation between those two:





