\section{Functions and methods}
\label{sec:functions}

\emph{Functions} and \emph{methods} are fundamental concepts in
writing code in object-orientated programming. Both are objects that
we use to store a set of statements and operations that we can later
use without writing the whole syntax again. This makes our code
simpler and more powerful.

We have already used some built-in functions, such as \fn{length} and
\fn{class} (R) and \fn{len} and \fn{type} (Python) to get the length
of an object and the class to which it belongs. But, as you will learn
in this chapter, you can also write your own functions. In essence, a
function takes some input (the \emph{arguments} supplied between
brackets) and returns some output.  Methods and functions are very
similar concepts. The difference between them is that the functions
are defined independently from the object, while methods are created
based on a class, meaning that they are associated to an object. For
example, in Python, each string has an associated method \fn{lower},
so that writing |'HELLO'.lower()| will return 'hello'. In R, in
contrast, one uses a function, |tolower('HELLO')|. For now, it is not
really important to know why some things are implemented as a method
and some are implemented as a function; it is partly an arbitrary
choice that the developers made, and to fully understand it, you need
to dive into the concept of \fn{class}es, which is beyond the scope of
this book.

\note{Because methods are associated with an object, you have a very
  useful trick at your disposal to find out which methods (and other
  properties of an object) there are: TAB completion. In Jupyter, just
  type the name of an object followed by a dot (e.g., \texttt{a.\textbar} in case you
  have an object called a) and hit the TAB key. This will open a
  drop-down menu to choose from.}


We will illustrate how to create simple functions in R and Python, so you
will have a better understating of how they work. Imagine you want to
create two functions: one that computes the 60\% of any given number
and another that estimates this percentage only if the given argument
is above the threshold of 5. The structure of a function in R is:

\begin{verbatim}
function_name <- function(arg_1, arg_2, ...) {
   Function body 
}
\end{verbatim}

In Python it is:

\begin{verbatim}
def function_name(arg_1, arg_2, ...):
  statement
\end{verbatim}

\refex{functions} shows how to write our function and how to use it.
\pyrex[caption=Writing functions,output=py]{chapter03/functions}

The power of functions, though, lies in scenarios where they are used
repeatedly.  Imagine that you have a list of 5 (or 5 million!) scores
and you wish to apply the function |por_60_cond| to all the scores at
once using a loop. This costs you only two extra lines of code
(\refex{functions2}).

\pyrex[caption=Functions are particular useful when used repeatedly,output=py]{chapter03/functions2}


\begin{feature}
  A specific type of Python functions that you may come across at one point (for instance, in \refsec{crawling}) is the \fn{generator}. Think of a function that returns a list of multiple values. Often, you do not need all values at once: you may only need the \emph{next} value at a time. This is especially interesting when calculating the whole list would take a lot of time or a lot of memory. Rather than waiting for all values to be calculated, you can immediately begin processing the first value before the next arrives; or you can work with data so large that do not fit into your memory at the same time.  You recognize a generator by the |yield| keyword instead of a |return| keyword (\refex{generators})
\end{feature}

\pyrex[input=py, output=py, caption={Generators behave like lists in that you can iteratre (loop) over them, but each element is only calculated when it is needed. Hence, they do not have a length.}]{chapter03/generators}



\begin{feature}
  A central concept of object-oriented programming that we do not cover in this book are \fn{class}es. You can think of them as a blueprint for creating an object, and sometimes, this will shine through. For instance, if we write \texttt{c = Counter()} in Python, we create a new object \texttt{c}. This object is an \emph{instance} of the \emph{class} Counter (which we need to import from the package \pkg{collections} first). A counter is a class that allows you to count things, such as the most common words in a list of strings. You could say that you created your own counter, c, based on a template, the class Counter. In R, there are even different types of classes, called S3, S4, and reference. However, you are less likely to get exposed to them in your daily work.
  \end{feature}



%Now that you have gone through most types of objects in R and Python, we need to remember that objects are different from classes, as we mentioned at the beginning of this section. A class is a prototype with attributes that helps to build an object when it is created from that class. R has three class systems: S3 class, S4 class and Reference Class.  Imagine that we have some data of a news item that we want to convert to a class using the basic S3 class:

%\begin{exampler}
%news <- list(headline = "Scientists discover how to cure AIDS", date = 21012030, positive_tone = TRUE)
%class(news) <- "news_piece"
%\end{exampler}

%Or using Reference Class:

%\begin{exampler}
%setRefClass("news_piece")
%\end{exampler}

%Then you have stored the information of the class news\_piece.  You can do this also with S4 class, which allows you to define the formal structure of the class:

%\begin{exampler}
%setClass("news_piece", slots=list(headline="character", date="numeric", positive_tone="logical"))
%\end{exampler}

%Using S4 class definition you can create a new object using the attributes of the created class, which is very useful to maintain consistency:

%\begin{exampler}
%news2 <- new("news_piece", headline="Thousands of new refugees run from hunger after war begins", date=22012030, positive_tone = FALSE)
%\end{exampler}

%On the contrary, Python has just a single class. We define the class in a similar way we will define functions (see next section). We use the keyword class and, in some cases, the built-in \_\_init\_\_() function.  Let's create a very single class in Python including a numeric object in the class and later using that class to define a new object:

%\begin{examplepy}
%class MyWeight:
%...    	 x = 74
%weigth = MyWeight()
%print (weigth.x)
%\end{examplepy}

%As you see, we created the object \emph{weight} using the properties (x in this case) of the class MyWeight. This procedure is probably of limited use but good to illustrate what a class is in Python. A more interesting approach to create the class is using the \_\_init\_\_() function, which is a special function that assigns values to object properties and is executed when the class is being initiated. In simpler words, this function helps us to assign different values within the class, creating an internal structure that will be used when we create an object based on that class. You can run the next example on your Python console for a better understanding of the concept. Imagine you want to create the same class news\_piece we did in R and then use that class to create an object:

%\begin{examplepy}
%class news_piece:
%...     def __init__(self, headline, date, positive_tone):
%...             self.headline = headline
%...             self.date = date
%...             self.positive_tone = positive_tone
%news2 = news_piece("Thousands of new refugees run from hunger after war begins", 22012030, False)
%print(news2.headline)
%\end{examplepy}

%As you see, with the last line of the code we obtain a part of the created object (in this case the headline) based on the structure designed in the class news\_piece.


