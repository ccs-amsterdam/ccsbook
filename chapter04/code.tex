\section{Re-using code}
\label{sec:code}

Coding is like speaking a language. This means that you have a vocabulary, syntax rules and expressions; and that you think of sentences, words and letters. Using the proper words and grammar, you can build from scratch any idea your background and imagination allow you, which is a wonderful thing of language. However, language it self, as well as expressions, ideas and more abstract constructs seldom come originally from you, which is also great because you do not have to deeply think of every element before talking and expressing any common or innovative thought. Instead, you use pre-existing languages, rules, ideas, perceptions and many different narratives to create your own messages to interact with the world. We think that this philosophical example can illustrate how coding works and how important is your coding community when you have to conduct any computational approach.

Of course you can always code from the very beginning anything you want: even just using 0's and 1's! In fact, when you attend your first lesson of programming it is likely you to think that complex operations will be very exhausting and will take a really a long time. This fear is completely understandable, but it is far away from being realistic for most practitioners. Computational scientists, data analysts and even developers normally re-use earlier code in order to achieve their goals quicker and more efficiently. This practice has many advantages in terms of time and resources, because you will certainly spend less efforts to conduct a task if you use the work made by other fellows and do not have to re-invent the wheel.

Differently to humanities and social sciences, in most of the computational routines this "copy-and-paste" practices do not represent an offence for intellectual property, but on the contrary, an extended practice of collaboration. It is also true that at certain levels you will come across the discussion between software property, technological patents or intellectual rights against the open-source model, but in general you will mostly find a collaboration and additive spirit when using coding for research.

There are different ways to re-use earlier code. One is to copy and adapt raw lines of code written by someone else or by ourselves in the past. In fact, there many online repositories where you can find previous code, such as Github, BitBucket, GitLab, SourceForge, OSON or SubVersion, from where anyone can pull documented code examples (see Section~\ref{sec:practices}). When conducting computational analysis you will spend a significant part of your time in some these repositories trying understand what others have done and figuring out how can use it your own work.

Another way is to build or import functions that summarizes many lines of code into a simpler command, as we explained in Section~\ref{sec:functions}. The functions are indeed powerful strategies to re-use the code since you do not have to write over and over again complex lines of code that have to be used in different moments. Packages are probably the most elegant approach to recycle the work made by other colleagues. In Section~\ref{sec:installing} you already learnt how to install a package and you did probably noticed how easy it is to bring many pre-build functionalities onto your workspace. You can also write and publish your own package in the future to help your colleagues to write less code and to be more efficient in their daily job!

As you may imagine, in the above-mentioned repositories you will get not only raw code, but also scripts that include many functions, or even complete packages. This means that re-using code is not a linear or well-organized task. On the contrary, you will be back and forth looking for previous code and adapting yours iteratively.

Probably the main questions are: what to re-use?, when to use a function instead ow writing the whole code?, which scripts and sources are trustful? Which is the best package to choose?, how many packages should we use within the same project?, should we care about package versions? or, must we learn every package is released in our field? There are of course multiple answers to these questions and it will be probably a matter of practice how to obtain the most appropriate ones. In general, we can say that one premise is to re-use and share code as much as you can. This idea is limited by constraints of quality, availability, parsimony, update and expertise. In other words, when recycling code we should think of the reputation of the source, the difficulty to access it, the risk of having an excessive and messy number of inputs, the need to use the last developments with your colleagues and the fact that you will not be able to know-it-all.

In the case of package selection, you will probably feel that the decision-making process is challenging and that it is too risky to spend time selecting and learning a package that would later not be useful. And you are right to think so: even if you have to  \textit{flirt} with many libraries and even become a \textit{early adopter}, you will finally pay attention to what your community is using at the very moment in order to take a decision of to invest your time. 

Just to mention an example, the authors of this book had several intensive discussions of which packages to mention and use in the proposed exercises, an issue that became complex given the variety of topics addressed in the handbook. In the case of text analysis, a library such as \fn{NLTK} for Python was incredibly popular among computational analysts until few years ago becoming a package of reference in the field, but it has been overpassed by friendly and sophisticated new packages for natural language processing like \fn{SpaCy}. So, which should we have included in this handbook? The one which is well-known (with excellent documentation by the way) and still used by thousands of practitioners and students around the world?, or the one which is penetrating the market because of its easiness and advantages? Moreover, by choosing the second option, are we sure a more trendy package is going to be stable in time or is it going to be crossed out by a different one in just few months?  

As you see, there are few certainties about how to re-use code and packages, but this dynamic scenario also depicts an exciting and provocative field that forces us to keep ourselves updated.